function ProLims = find_Swims_profiles(pr, yday);% [profile_begin,profile_end,up_down,bad_flags]=get_profiles(pr,day);%% Turns SWIMS saw-tooths into profiles.  Longterm pressure inversions are% the necessary criteria for the profiles to be turning around.  Lets asume% the fall rate and the pull up rate must be greater than 10cm/s...%   up_down=-1 means that pressure was increasing.  up_down=+1 means%   pressure was decreasing.%   bad_flags is a list of data that is bad, but still inside a "profile".%   This edits loops in the line etc.SecBW = 2; % length of 4th-order Butterworth filter to lowpass pressure dataSecWCD = 2 + 3; % length in seconds for computing center-difn fallratesHzSamp = 24; % sampling frequency of pres,yday dataPtoZ = 100; % factor to convert pressures to depth in metersMetProf = 5 + 25; % minimum length (m) for profilesSecGap = 3; % sample gaps (recorded) exceeding this are flagged as discontinuitiesSecTSer = 8 + 20; % minimum length (s) for time seriesWmsProf = 0.05 + 0; % minimum profiling speed (m/s)% Compute (even) number of samples >= filter timesNumBW = ceil(SecBW*HzSamp/2)*2; NumWCD = ceil(SecWCD*HzSamp/2)*2;NhfBW = NumBW/2; NhfWCD = NumWCD/2; % half lengths% Get filter coefsif NumBW >= 2    [bBW,aBW] = MHAButter(1/HzSamp ,SecBW);end% Force column vectors, exclude bad pressure or time dataif size(pr,1) == 1    pr = pr';endif size(yday,1) == 1    yday = yday';endix = find(isnan(pr+yday));pr(ix)=[]; yday(ix)=[];% Find gaps in data, save index ranges for continuous blocks% [i.e., CTD data are considered to be continuously sampled at HzSamp%   within each block, although recorded (PC) time may deviate slightly]igp = find(diff(yday)*86400 > SecGap);iBs = [ 1 ];iEs = [];for i=1:length(igp)    iEs(end+1) = igp(i); iBs(end+1) = igp(i)+1;endiEs(end+1) = length(yday);% Exclude short blocks (add to previous gap, effectively)ix = find( iEs-iBs < 2*(NumBW+NumWCD)+5 );iBs(ix)=[]; iEs(ix)=[];clear ProLimsProLims = [];% Is there enough data?if isempty(iBs)    disp('find_Swims_profiles: Too few continuous data to proceed!')    returnendProLims.yday_beg = [];ProLims.yday_end = [];ProLims.pr_beg = [];ProLims.pr_end = [];ProLims.samples = [];ProLims.type = [];for iCK = 1:length(iBs)    prS = pr( iBs(iCK):iEs(iCK) );    prLP = prS;    ydS = yday( iBs(iCK):iEs(iCK) );    if NumBW >= 2 % Apply lowpass BW (2-way), if indicated        prLP = filtfilt(bBW, aBW, prS);    end    % compute fallrates (m/s; down>0, up<0); match indices of prLP(:),ydS(:)    wS = ( prLP(NumWCD+1:end) - prLP(1:end-NumWCD) ) * PtoZ / (NumWCD/HzSamp);    ydS([1:NhfWCD, end+1-NhfWCD:end]) = [];    prLP([1:NhfWCD, end+1-NhfWCD:end]) = [];       % exclude points near ends to avoid filter effects    if NhfBW >= 1        wS([1:NhfBW, end+1-NhfBW:end]) = [];        ydS([1:NhfBW, end+1-NhfBW:end]) = [];        prLP([1:NhfBW, end+1-NhfBW:end]) = [];    end        wDir = 0*wS; % initialize as NOT profiling    iu = find(wS < -WmsProf);    wDir(iu) = 1;  % upward    id = find(wS > WmsProf);    wDir(id) = -1; % downward    dwDir = diff(wDir);    delDir = find(dwDir~=0); % indexes of direction changes    % Gather index ranges, attributes for each interval (up,down,pause/level ?)    inB = [1; delDir+1];    inE = [delDir; length(ydS)];    prB = prLP(inB); prE = prLP(inE);    wDir = wDir(inB);    delZ = (prE - prB) * PtoZ;    %    iux = find(wDir>0 & abs(delZ)<MetProf);    wDir(iux) = 2; % upward, but too short    idx = find(wDir<0 & abs(delZ)<MetProf);    wDir(idx) = -2; % downward, but too short    % Now, find profiles, add short 'profiles' to time series limits    savInd = [];    nowDir = NaN; % current, working direction    for iPf = 1:length(wDir)        newDir = wDir(iPf);        if abs(newDir) > 1            % ignore short profiles at ends (they may extend further pre/post)            if (iPf==1 | iPf==length(wDir))                continue;             else                newDir = 0; % treat as non-profile            end        end        if newDir ~= nowDir            if ~isnan(nowDir) % save current limits, direction                boff = 0;                % tighten profile limits by a portion of the fall rate interval                if abs(nowDir)==1                    boff = floor(NhfWCD * 0.25);                end                savInd = [savInd;  ipB+boff ipE-boff nowDir];            end            % initialize next one            nowDir = newDir;            ipB = inB(iPf); ipE = inE(iPf);        else            ipE = inE(iPf); % same direction, just extend end limit        end    end % of finding 'real' profiles, patching together time series    if ~isnan(nowDir) % save final limits, direction         savInd = [savInd;  ipB ipE nowDir];    end    % Remove short delays between profiles    ix = find(savInd(:,3)==0 & (savInd(:,2)-savInd(:,1))/HzSamp < SecTSer );    % But, save those that just interrupt profiles in same direction    % [e.g., pressure loops]    ic = find(ix>1 & ix<length(savInd(:,3)));    ig = find( savInd(ix(ic)-1,3) == savInd(ix(ic)+1,3) ); % same dir    ix(ic(ig)) = [];    if ~isempty(ix)        savInd(ix, :) = [];    end        %keyboard    % Accumulate results in output structure    ProLims.yday_beg = [ProLims.yday_beg; ydS(savInd(:,1))];    ProLims.yday_end = [ProLims.yday_end; ydS(savInd(:,2))];    ProLims.pr_beg = [ProLims.pr_beg; prLP(savInd(:,1))];    ProLims.pr_end = [ProLims.pr_end; prLP(savInd(:,2))];    ProLims.samples = [ProLims.samples; savInd(:,2)-savInd(:,1)+1];    ProLims.type = [ProLims.type; savInd(:,3)];    % Also, record gap(s) between continuous blocks of data    if iCK < length(iBs)        ProLims.yday_beg = [ProLims.yday_beg; yday(iEs(iCK))+1/86400];        ProLims.yday_end = [ProLims.yday_end; yday(iBs(iCK+1))-1/86400];        ProLims.pr_beg = [ProLims.pr_beg; pr(iEs(iCK))];        ProLims.pr_end = [ProLims.pr_end; pr(iBs(iCK+1))];        ProLims.samples = [ProLims.samples; 0];        ProLims.type = [ProLims.type; NaN];    endend % of loop thru continuous blocks of data, for iCK = 1:length(iBs)    