function [SWIMSraw]=Read_rawCTsHEX_SWIMS(filename, Version, ByteRange,year)% [SWIMSraw]=Read_rawCTsHEX_SWIMS(filename, Version, ByteRange);% Convert raw CTD data (counts, as integers) to Matlab data. % filename = file written by acquisition program;% Version = identifies format, 1=SWIMS 1 (pre-2002), 2=SWIMS 2 (default).% Following data are returned in fields of structure SWIMSraw:%   tfreq, cfreq, pfreq, tfreq2, cfreq2 = primary temp, cond, pressure,%       secondary temp, cond  (all in 0:2^24-1);%   addata = Voltages (0:2^12-1) from 4/8 A-to-D channels (4/8xNrecs);%   tprCT = compensation temp (8/12-bit count) for pressure;%   status = 4-bit status info (pump on, etc.);%   modCT = modulo count (0-255, 8-bit integer>0);%   SWIMStime = timestamp (PC clock), seconds since Jan 1, 1900 00:00:00,%       returned as Matlab datenum = days with 1 = Jan 1, 0000 00:00:00.%   SWIMSfasttime = elapsed seconds since acquistion session began.% April,2002 by D.Winkel:  This version reduces resulting *.mat file size%   by almost 1/3 relative to saving as Hz,Volts in double arrays, if%   more than 10,000 (7 minutes) scans are saved.  Requires conversion%   to Hz (cts/256) or Volts [via AtoD_SWIMS.m] %   prior to applying calibrations.% Deck box transmits hex characters, (24 or 30)/scan, then CR,LF;% Acquisition program timestamps and outputs as binary data to files:%   first 4 bytes are integer clock value - in seconds;%   next 8 bytes are double elapsed time value (seconds); %   next 24 (SWIMS 1) or 30 (SWIMS 2) bytes are a CTD data scan.% As of 2015, Scripps acquisition files are hex characters%   as sent by deckbox, with timestamp APPended to each record.% Also, added input argument=ByteRange and output field=LastByte to allow%   parsing of file only between specified byte positions [begin, end],%   and to report last byte in file that was actually processed - DPWSWIMSraw = [];if nargin<2 || isempty(Version)    Version = 2; % for SWIMS 2/3 (hex only after 2014 by Scripps)endif nargin<3 || isempty(ByteRange)    ByteRange = [0, inf]; % for SIO-type files onlyend% specify sizes/positions of fields in recordsif Version == 2    CTbyH = [1:30]; ADbyH = [31:54]; % hex char positions    tPRbyH = [55:57]; sTAbyH = 58; MODbyH = [59:60];    TimSposn = [62:80]; % timestamp characters    ckCHARS = [61,9; 70,abs('T'); 81,32]; % tab,'T',space positions    REClen = 81; % valid record lengthenddate_orig = datenum(year,1,1,0,0,0); % for now, backward comp for fasttime%Open the file[fid,message]=fopen(filename,'r');if fseek(fid, ByteRange(1), 'bof') < 0  % start reading here    warning(['starting byte ' num2str(ByteRange(1)) ' past end-of-file'])    fclose(fid);    returnend% count possible valid records before initializingRct = 0;R = fgetl(fid);while ischar(R) && ftell(fid)<=ByteRange(2)    if length(R) == REClen        Rct = Rct + 1;    end    R = fgetl(fid);end% initialize structureflds = {'SWIMStime','SWIMSfasttime','tfreq','cfreq','pfreq', ...    'tfreq2','cfreq2','tprCT','status','modCT'};for i=1:length(flds)    SWIMSraw.(flds{i}) = NaN*ones(1,Rct);endSWIMSraw.addata = NaN*ones(8,Rct);% Go back, process valid recordsfseek(fid, ByteRange(1), 'bof');SWIMSraw.LastByte = ftell(fid);Rct = 0;R = fgetl(fid);while ischar(R) && ftell(fid)<=ByteRange(2)    if length(R) ~= REClen        R = fgetl(fid);        continue; % correct length?    end    c=0; % characters as predicted?    for i=1:length(ckCHARS(:,1))        if abs( R(ckCHARS(i,1)) ) - ckCHARS(i,2)            c=1;        end    end    if c        R = fgetl(fid);        continue;    end    try % may encounter non-Hex characters, if so skip line        FQ = hex2dec( reshape(R(CTbyH)', 6, 5)' );        AD = hex2dec( reshape(R(ADbyH)', 3, 8)' );        Etc = [];        Etc(1) = hex2dec(R(tPRbyH));        Etc(2) = hex2dec(R(sTAbyH));        Etc(3) = hex2dec(R(MODbyH));                TmStp = datenum(R(TimSposn), 'yyyymmddTHHMMSS.FFF');    catch        R = fgetl(fid);        continue;    end    Rct = Rct+1;    SWIMSraw.SWIMStime(Rct) = TmStp;    SWIMSraw.SWIMSfasttime(Rct) = (TmStp - date_orig)*86400; % bkwrds compatable    SWIMSraw.tfreq(Rct) = FQ(1);    SWIMSraw.cfreq(Rct) = FQ(2);    SWIMSraw.pfreq(Rct) = FQ(3);    SWIMSraw.tfreq2(Rct) = FQ(4);    SWIMSraw.cfreq2(Rct) = FQ(5);    SWIMSraw.addata(1:8,Rct) = AD;    SWIMSraw.tprCT(Rct) = Etc(1);    SWIMSraw.status(Rct) = Etc(2);    SWIMSraw.modCT(Rct) = Etc(3);    %for testing, save text lines:    %SWIMSraw.Record{Rct} = R;    SWIMSraw.LastByte = ftell(fid);    %     if mod(Rct,100000) == 0%         disp(Rct)%     end    R = fgetl(fid);end % of reading, converting CTD hex records with timestamps appendedstatus = fclose(fid);if Rct>0    flds = {'SWIMStime','SWIMSfasttime','tfreq','cfreq','pfreq', ...        'tfreq2','cfreq2','addata','tprCT','status','modCT'};    for i=1:length(flds) % trim to valid records processed        SWIMSraw.(flds{i}) = SWIMSraw.(flds{i})(:,1:Rct);    end    SWIMSraw.AtoD = '5*(1-cts/4095)'; % note count-to-V conversion    SWIMSraw.FastTime_Origin = date_orig;else    clear SWIMSraw    SWIMSraw = [];end