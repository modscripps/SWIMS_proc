function [SWIMSraw]=Read_rawCTs_SWIMS(filename, Version)% [SWIMSraw]=Read_raw2_SWIMS(filename, Version);% Convert raw CTD data (counts, as integers) to Matlab data. % filename = file written by acquisition program;% Version = identifies format, 1=SWIMS 1 (pre-2002), 2=SWIMS 2 (default).% Following data are returned in fields of structure SWIMSraw:%   tfreq, cfreq, pfreq, tfreq2, cfreq2 = primary temp, cond, pressure,%       secondary temp, cond  (all in 0:2^24-1);%   addata = Voltages (0:2^12-1) from 4/8 A-to-D channels (4/8xNrecs);%   tprCT = compensation temp (8/12-bit count) for pressure;%   status = 4-bit status info (pump on, etc.);%   modCT = modulo count (0-255, 8-bit integer>0);%   SWIMStime = timestamp (PC clock), seconds since Jan 1, 1900 00:00:00,%       returned as Matlab datenum = days with 1 = Jan 1, 0000 00:00:00.%   SWIMSfasttime = elapsed seconds since acquistion session began.% April,2002 by D.Winkel:  This version reduces resulting *.mat file size%   by almost 1/3 relative to saving as Hz,Volts in double arrays, if%   more than 10,000 (7 minutes) scans are saved.  Requires conversion%   to Hz (cts/256) or Volts [via AtoD_SWIMS.m] %   prior to applying calibrations.% Deck box transmits hex characters, (24 or 30)/scan, then CR,LF;% Acquisition program timestamps and outputs as binary data to files:%   first 4 bytes are integer clock value - in seconds;%   next 8 bytes are double elapsed time value (seconds); %   next 24 (SWIMS 1) or 30 (SWIMS 2) bytes are a CTD data scan.%if nargin<2 | isempty(Version)    Version = 2; % for SWIMS 2end% specify sizes/positions of 8-bit and 12-bit fields in recordsif Version == 2    TSbyt = [4, 8]; CTbyt = 30; % 8-bit bytes    ADfmt = 28; ADbyt = [19:26]; ETCbyt = [27 28]; % 12-bit wordselseif Version == 1    TSbyt = [4, 8]; CTbyt = 24;     ADfmt = 24; ADbyt = [19:22]; ETCbyt = [23 24];end TSoff = sum(TSbyt); % total time-stamp bytesdate_1900 = datenum(1900,1,1);   %Open the file as little-endian since it was written on a PC.[fid,message]=fopen(filename,'r','ieee-le');% read the clock values, skip elapsed&scan bytes after each[d, count] = fread(fid, inf, 'uint32', TSbyt(2)+CTbyt);SWIMSraw.SWIMStime = date_1900 + d' / 86400; % MatLab datenum% read elapsed time values, skip scan&clock bytes after eachstatus = fseek(fid, TSbyt(1), 'bof');SWIMSraw.SWIMSfasttime = fread(fid, inf, 'double', CTbyt+TSbyt(1))';frewind(fid);  % 8-bit bytes[d, count] = fread(fid, [TSoff+CTbyt, inf], 'uchar');%Get temp - first three bytes after the time stampsSWIMSraw.tfreq = ( d(TSoff+1,:)*256+d(TSoff+2,:) )*256 + d(TSoff+3,:);%Get cond - next threeSWIMSraw.cfreq = ( d(TSoff+4,:)*256+d(TSoff+5,:) )*256 + d(TSoff+6,:);%Get pres - next threeSWIMSraw.pfreq = ( d(TSoff+7,:)*256+d(TSoff+8,:) )*256 + d(TSoff+9,:);%Get temp2 - next threeSWIMSraw.tfreq2 = ( d(TSoff+10,:)*256+d(TSoff+11,:) )*256 + d(TSoff+12,:);%Get cond2 - next threeSWIMSraw.cfreq2 = ( d(TSoff+13,:)*256+d(TSoff+14,:) )*256 + d(TSoff+15,:);% A/D Data.%Now rewind and load in data as 12-bit words.%Total record yields 24 such words for SWIMS 1, 28 words for SWIMS 2.%The first 8 are the time stamps, the next 10 are the 15 bytes of CTD scan%frequencies, and the next 4 (S1) or 8 (S2) are A/D channels.%The last two words have pres.comp.temp, status, and modulo count.% (Note it is important to close and reopen the file as bigendian so the %  bit orders are correct.)fclose(fid);[fid,message]=fopen(filename,'r','ieee-be');frewind(fid);[d2, count] = fread(fid, [ADfmt, inf], 'ubit12');%close the filestatus = fclose(fid);% Convert counts to Volts, and gather misc data from last 2 wordsaddata = d2(ADbyt,:);if Version == 2    SWIMSraw.addata = addata; % 12-bit ints    SWIMSraw.tprCT = d2(ETCbyt(1),:); % 12-bit uint    SWIMSraw.status = floor(d2(ETCbyt(2),:)/256); % first 4 bits    SWIMSraw.modCT = mod(d2(ETCbyt(2),:),256); % last 8 bits    SWIMSraw.AtoD = '5*(1-cts/4095)'; % note count-to-V conversionelseif Version == 1    SWIMSraw.addata = addata; % 12-bit ints    SWIMSraw.tprCT = floor(d2(ETCbyt(1),:)/16); % 8-bit unit (first 8 of 12)    SWIMSraw.status = floor(d2(ETCbyt(2),:)/256); % only LSB is used (pump off/on)    SWIMSraw.modCT = mod(d2(ETCbyt(2),:),256); % last 8 bits    SWIMSraw.AtoD = '10*(1-2*cts/4096)'; % note count-to-V conversionend%