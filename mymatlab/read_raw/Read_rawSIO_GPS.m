function GStruct=Read_rawSIO_GPS(filename, NMstr, ByteRange)%function GStruct=Read_rawSIO_GPS(filename, NMstr, ByteRange)%Pass in a filename, and return structure GStruct with fields:%  PCyday = row vector of computer timestamp (yearday type),%  PCfasttime = row vector of elasped time (seconds) [for bkwd compat only],%  sattime = row vector of GPS timestamp (yearday type),%  lat = row vector of latitude (decimal degrees, S<0),%  lon = row vector of longitude (decimal degrees, W<0),%  LastByte = last byte number in input file that was processed% % NMstr is optional, defaults to 'GPGGA', but 'GPGLL' is supported.% The files are ascii.% July 2007, added more error checking to catch com errors on Wecoma - DPW% Aug 2015, in Read_raw_GPS.m:%  added Ver (1=APL[default],2=SIO) and ByteRange ([0,inf] by default)%  to allow backwards compatability and option to parse strings with newer%  (post 2014), appended timestamps from Scripps acquisition.  For Ver=2, %  option to parse file only between specified byte positions [begin, end];%  Calls this routine (Read_rawSIO_GPS.m) for Ver = 2GStruct = [];if nargin<2 || isempty(NMstr)    NMstr = 'GPGGA';endif nargin<3 || isempty(ByteRange)    ByteRange = [0, inf]; % for SIO-type files onlyend% specify positions (comma-delimited) for GPS fieldsswitch NMstrcase 'GPGGA'    Plat=3;PlatH=4; Plon=5;PlonH=6; Ptime=2; okLen=45; okCom=6;case 'GPGLL'    Plat=2;PlatH=3; Plon=4;PlonH=5; Ptime=6; okLen=36; okCom=6;otherwise    error(['Unsupported NMEA type: ' NMstr]);endFstr = ['$' NMstr ','];HrPday=24; MinPday=1440; SecPday=86400;date_orig = datenum(2015,1,1,0,0,0); % for now, backward comp for fasttime% For SIO acquisition, timestamp is appended, so specify offsets%   relative to end of recordTimSposn = [-19:-1]; % timestamp characters, offsets from endckCHARS = [-20,9; -11,abs('T'); 0,32]; % tab,'T',space positions, from end[fid,message]=fopen(filename,'r');if fseek(fid, ByteRange(1), 'bof') < 0  % start reading here    warning(['starting byte ' num2str(ByteRange(1)) ' past end-of-file'])    fclose(fid);    returnend%count lines.line=fgetl(fid);counter=0;while ischar(line) && ftell(fid)<=ByteRange(2)    igga=findstr(Fstr,line);    if length(igga)==1 %if it's the proper NMEA string        counter=counter+1;    end    line=fgetl(fid);end%Make arrays for the answers.numrecs=counter;GStruct.PCyday=zeros(1,numrecs); % PC date/time that serial record was readGStruct.PCfasttime=zeros(1,numrecs); % PC elapsed seconds [obsolete for SIO]GStruct.sattime=zeros(1,numrecs);GStruct.lat=zeros(1,numrecs);GStruct.lon=zeros(1,numrecs);GStruct.LastByte = NaN;%rewind the file.fseek(fid, ByteRange(1), 'bof');%read in each lineline=fgetl(fid);counter=0; GStruct.LastByte = ftell(fid);while ischar(line) && ftell(fid)<=ByteRange(2)    igga=findstr(Fstr,line);    c=0; % characters as predicted?    if length(igga)~=1 || length(line)<okLen %  NOT proper NMEA record type        c=1;    else % check for timestamp delimiting characters        for i=1:length(ckCHARS(:,1))            if abs( line(end+ckCHARS(i,1)) ) ~= ckCHARS(i,2)                c=1;            end        end    end    if ~c % okay so far        % GGA=entire NMEA record, with timestamp removed        GGA = line(igga(1):end+ckCHARS(1,1)-1);         ic=findstr(GGA,',');        %disp([num2str(counter) ' ' GGA])        if length(GGA)>=okLen && length(ic)>=okCom            counter = counter+1; % valid record            GStruct.PCyday(counter) = NaN;            GStruct.PCfasttime(counter) = NaN;            GStruct.sattime(counter) = NaN;            GStruct.lat(counter) = NaN;            GStruct.lon(counter) = NaN;            %First get the timestamp.            try                x = datenum(line(end+TimSposn), 'yyyymmddTHHMMSS.FFF');            catch                x = -1;            end            if x>=0                GStruct.PCyday(counter) = x;            end                        %Parse GGA string.  Thanks to Eric MacDonald.            time=GGA(ic(Ptime-1)+1:ic(Ptime)-1); decday = -1;            if length(time)>5                decday = str2double(time(1:2))/HrPday + ...                    str2double(time(3:4))/MinPday + str2double(time(5:6))/SecPday;            end            if decday>=0 && decday<=1.2                 GStruct.sattime(counter) = decday; % fraction of a day            end                        lat = GGA(ic(Plat-1)+1:ic(Plat)-1);            latH = GGA(ic(PlatH-1)+1:ic(PlatH)-1);            lon = GGA(ic(Plon-1)+1:ic(Plon)-1);            lonH = GGA(ic(PlonH-1)+1:ic(PlonH)-1);            % convert to decimal degrees            if length(lat)>3 && length(lon)>4                latn = str2double(lat(1:2)) + str2double(lat(3:end))/60;                lonn = str2double(lon(1:3)) + str2double(lon(4:end))/60;                if (latn>=0&&latn<=90) && (lonn>=0&&lonn<=180)                    GStruct.lat(counter) = latn * (strcmp(latH,'N')*2-1); % N>0, S<0                    GStruct.lon(counter) = lonn * (strcmp(lonH,'E')*2-1); % E>0, W<0                end            end        end % of valid/complete NMEA record   	    end % of potential NMEA record    GStruct.LastByte = ftell(fid);    %Get the next line    line=fgetl(fid);end% check that any valid records were parsedfclose(fid);if counter<1    GStruct = [];    returnend% In case some incomplete records were encountered:GStruct.PCyday=GStruct.PCyday(1:counter);GStruct.PCfasttime=GStruct.PCfasttime(1:counter); GStruct.sattime=GStruct.sattime(1:counter);GStruct.lat=GStruct.lat(1:counter);GStruct.lon=GStruct.lon(1:counter);% clear errant records (com problems, etc.)ix = find(isnan(GStruct.PCyday+GStruct.sattime+...    GStruct.lat+GStruct.lon));if ~isempty(ix)    GStruct.PCyday(ix) = [];    GStruct.PCfasttime(ix) = [];    GStruct.sattime(ix) = [];    GStruct.lat(ix) = [];    GStruct.lon(ix) = [];end% Check for change of day in GPS time (more than 2 hours backward)idel = find(diff(GStruct.sattime) < -(2/HrPday));for i=1:length(idel)    GStruct.sattime(idel(i)+1:end) = GStruct.sattime(idel(i)+1:end) + 1; % add a dayend% convert datenums to yeardays, using year of first recordyr = datevec(GStruct.PCyday(1));yrdtnum = datenum(yr(1),1,1,0,0,0);GStruct.PCfasttime = (GStruct.PCyday - date_orig)*SecPday; % secondsGStruct.PCyday = GStruct.PCyday - yrdtnum;%% Given more than a few records, and PC times near UTC, assign yearday%   offset to GPS timesif length(GStruct.PCyday)>2    yd0 = floor(GStruct.PCyday(1)); % should be okay, unless very near midnight    dt0 = GStruct.PCyday(1)-yd0 - GStruct.sattime(1);    dte = mod(GStruct.PCyday(end),1) - mod(GStruct.sattime(end),1); % just in case    if abs(dt0)*MinPday < 5 || abs(dte)*MinPday < 5  % within 5 minutes        if dt0 > 0.9, yd0 = yd0 + 1; end % PC(1)<midnight<GPS(1)        if dt0 < -0.9, yd0 = yd0 - 1; end % GPS(1)<midnight<PC(1)        GStruct.sattime = GStruct.sattime + yd0;    endelseif ~isempty(GStruct.PCyday)    GStruct.PCyday=[]; GStruct.PCfasttime=[];    GStruct.sattime=[]; GStruct.lat=[]; GStruct.lon=[];    disp(['Fewer than 2 valid ' NMstr ' messages in file, skipping.'])end