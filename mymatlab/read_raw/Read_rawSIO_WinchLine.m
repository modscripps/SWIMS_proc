function LData = Read_rawSIO_WinchLine(filename,Typ,ByteRange)% function LData = Read_rawSIO_WinchLine(filename,ByteRange)% Pass in a filename for winch line data from the LCI90, and return% structure LData with fields:%   PCyday - timestamp from acquisition computer (yearday);%   LCIyday - timestamp in record from LCI90 (yearday);%   line_out - how much cable is out (meters);%   line_rate - speed that cable is going off of (>0) or on to (<0)%       drum (m/s converted from m/min);%   TensionLbs - line tension (lb);%   LastByte - scalar indicating last byte number processed for file%% Optional argument Typ in case of future changes to format, and%   ByteRange [min,max] to specify range of input file to be parsed%   % DPW - 8/2015LData = [];if nargin<2 || isempty(Typ)    Typ = 'RD';endif nargin<3 || isempty(ByteRange)    ByteRange = [0,inf];end% specify positions (comma-delimited) for LCI90 fieldsswitch Typ    case 'RD'        Pts=2; Ptens=3; Plrate=4; Plout=5; okLen=40; okCom=5;        Fstr = [char(30) char(1) 'RD,'];    otherwise        error(['Unsupported type: ' Typ]);end% For SIO acquisition, timestamp is appended, so specify offsets%   relative to end of recordTimSposn = [-19:-1]; % timestamp characters, offsets from endckCHARS = [-20,9; -11,abs('T'); 0,32]; % tab,'T',space positions, from end[fid,message]=fopen(filename,'r');if fseek(fid, ByteRange(1), 'bof') < 0  % start reading here    warning(['starting byte ' num2str(ByteRange(1)) ' past end-of-file'])    fclose(fid);    returnend%count lines.line=fgetl(fid);counter=0;while ischar(line) && ftell(fid)<=ByteRange(2)    igga=findstr(Fstr,line);    if length(igga)==1 %if it's the proper LCI90 string        counter=counter+1;    end    line=fgetl(fid);end%Make arrays for the answers.numrecs=counter;LData.PCyday=zeros(1,numrecs); % PC date/time that serial record was readLData.LCIyday=zeros(1,numrecs); % LCI90 date/time stampLData.line_out=zeros(1,numrecs);LData.line_rate=zeros(1,numrecs);LData.TensionLbs=zeros(1,numrecs);LData.LastByte = NaN;%rewind the file.fseek(fid, ByteRange(1), 'bof');%read in each lineline=fgetl(fid);counter=0; LData.LastByte = ftell(fid);while ischar(line) && ftell(fid)<=ByteRange(2)    igga=findstr(Fstr,line);    c=0; % characters as predicted?    if length(igga)~=1 || length(line)<okLen %  NOT proper LCI90 record type        c=1;    else % check for timestamp delimiting characters        for i=1:length(ckCHARS(:,1))            if abs( line(end+ckCHARS(i,1)) ) ~= ckCHARS(i,2)                c=1; % not found in correct position            end        end    end    if ~c % okay so far        % GGA=entire LCI90 record, with timestamp removed        GGA = line(igga(1):end+ckCHARS(1,1)-1);         ic=findstr(GGA,',');        %disp([num2str(counter) ' ' GGA])        if length(GGA)>=okLen && length(ic)>=okCom            counter = counter+1; % valid record            LData.PCyday(counter) = NaN;            LData.LCIyday(counter) = NaN;            LData.line_out(counter) = NaN;            LData.line_rate(counter) = NaN;            LData.TensionLbs(counter) = NaN;            % First get the PC timestamp.            try                x = datenum(line(end+TimSposn), 'yyyymmddTHHMMSS.FFF');            catch                x = -1;            end            if x>=0                LData.PCyday(counter) = x;            end                        %Parse LCI90 string; first the LCI90 timestamp:            time=GGA(ic(Pts-1)+1:ic(Pts)-1);            try                x = datenum(time, 'yyyy-mm-ddTHH:MM:SS.FFF');            catch                x = -1;            end            if x>=0                LData.LCIyday(counter) = x;            end            % now, the rest            tens = GGA(ic(Ptens-1)+1:ic(Ptens)-1);            lrate = GGA(ic(Plrate-1)+1:ic(Plrate)-1);            lout = GGA(ic(Plout-1)+1:ic(Plout)-1);            % convert to numeric            %%Pts=2; Ptens=3; Plrate=4; Plout=5; okLen=40; okCom=5;            if ~isempty(tens)                try                    LData.TensionLbs(counter) = str2num(tens);                catch                    x=0;                end            end            if ~isempty(lrate)                try                    LData.line_rate(counter) = str2num(lrate);                catch                    x=0;                end            end            if ~isempty(lout)                try                    LData.line_out(counter) = str2num(lout);                catch                    x=0;                end            end                    end % of valid/complete LCI90 record   	    end % of potential LCI90 record    LData.LastByte = ftell(fid);    %Get the next line    line=fgetl(fid);end% check that any valid records were parsedfclose(fid);if counter<1    LData = [];    returnend% In case some incomplete records were encountered:LData.PCyday=LData.PCyday(1:counter);LData.LCIyday=LData.LCIyday(1:counter); LData.TensionLbs=LData.TensionLbs(1:counter);LData.line_rate=LData.line_rate(1:counter) / 60; % m/sec from m/minLData.line_out=LData.line_out(1:counter);% clear errant records (com problems, etc.)ix = find(isnan(LData.PCyday+LData.LCIyday+...    LData.TensionLbs+LData.line_rate+LData.line_out));if ~isempty(ix)    LData.PCyday(ix) = [];    LData.LCIyday(ix) = [];    LData.TensionLbs(ix) = [];    LData.line_rate(ix) = [];    LData.line_out(ix) = [];end% convert datenums to yeardays, using year of first recordyr = datevec(LData.PCyday(1));yrdtnum = datenum(yr(1),1,1,0,0,0);LData.PCyday = LData.PCyday - yrdtnum;LData.LCIyday = LData.LCIyday - yrdtnum;