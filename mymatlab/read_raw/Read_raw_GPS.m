function [PCtimestamp,PCfasttime,GPStime,GPSlat,GPSlon,LastByte]=Read_raw_GPS(filename, NMstr, Ver, ByteRange)%function [PCtimestamp,PCfasttime,GPStime,lat,lon,LastByte]=Read_raw_GPS(filename,NMstr)%Pass in a filename, and return row vectors of the timestamp, elapsed time,%gps time (get yday from PCtime), and latitude and longitude for each record.%NMstr is optional, defaults to 'GPGGA', but 'GPGLL' is supported.%The files are ascii.% July 2007, added more error checking to catch com errors on Wecoma - DPW% Aug 2015: added Ver (1=APL[default],2=SIO) and ByteRange ([0,inf] by default)%  to allow backwards compatability and option to parse strings with newer%  (post 2014), appended timestamps from Scripps acquisition.  For Ver=2, %  option to parse file only between specified byte positions [begin, end]PCtimestamp=[];PCfasttime=[];GPStime=[];GPSlat=[];GPSlon=[];LastByte = NaN;if nargin<2 || isempty(NMstr)    NMstr = 'GPGGA'; Ver = 1;endif nargin<3 || isempty(Ver)    Ver = 1;endif nargin<4 || isempty(ByteRange)    ByteRange = [0, inf]; % for Ver=2 onlyendif Ver == 2 % Scripps style timestamp    GPS = Read_rawSIO_GPS(filename, NMstr, ByteRange);    if ~isempty(GPS) % copy returned fields to output variables        PCtimestamp=GPS.PCyday; PCfasttime=GPS.PCfasttime;        GPStime=GPS.sattime; GPSlat=GPS.lat; GPSlon=GPS.lon;        LastByte=GPS.LastByte;    end    returnend% Continue with pre-2015 Ver=1 conversion ...% specify positions (comma-delimited) for GPS fieldsswitch NMstrcase 'GPGGA'    Plat=3;PlatH=4; Plon=5;PlonH=6; Ptime=2; okLen=45; okCom=6;case 'GPGLL'    Plat=2;PlatH=3; Plon=4;PlonH=5; Ptime=6; okLen=36; okCom=6;otherwise    error(['Unsupported NMEA type: ' NMstr]);endFstr = ['$' NMstr ','];HrPday=24; MinPday=1440; SecPday=86400;[fid,message]=fopen(filename,'r');%count lines.line=fgetl(fid);counter=0;while ischar(line)    igga=findstr(Fstr,line);    if ~isempty(igga) %if it's the proper NMEA string        counter=counter+1;    end    line=fgetl(fid);end%Make arrays for the answers.numrecs=counter;PCtimestamp=zeros(1,numrecs); % PC date/time that serial record was readPCfasttime=PCtimestamp; % PC elapsed seconds since acquisition program was startedGPStime=PCtimestamp;GPSlat=PCtimestamp;GPSlon=PCtimestamp;%rewind the file.frewind(fid);%read in each lineline=fgetl(fid);counter=0; LastByte = ftell(fid);while ischar(line)	    igga=findstr(Fstr,line);    if ~isempty(igga) % proper NMEA record type        [GGA var]=strtok(line(igga(1):end)); % GGA=entire NMEA record        ic=findstr(GGA,',');        %disp([num2str(counter) ' ' GGA])        if length(GGA)>=okLen && length(ic)>=okCom            counter = counter+1; % valid record            PCtimestamp(counter) = NaN;            PCfasttime(counter) = NaN;            GPStime(counter) = NaN;            GPSlat(counter) = NaN;            GPSlon(counter) = NaN;            %First get the timestamp.            off=0;            try                year=str2double(line(off+1:off+4));                yday0=str2double(line(off+5:off+7)); % yearday (Jan 1 = 0.nnnn)                hour=str2double(line(off+8:off+9));                min=str2double(line(off+10:off+11));                sec=str2double(line(off+12:off+13));                x = yday0 + hour/HrPday + min/MinPday + sec/SecPday;                if x>=0 && x<=367                    PCtimestamp(counter) = x;                end                %Elapsed time next.                tmp=line(off+15:off+30);                iord=[15 16 13 14 11 12 9 10 7 8 5 6 3 4 1 2];                x = hex2num(tmp(iord));            catch                x = -1;            end            if x>=0                PCfasttime(counter) = x;            end                        %Parse GGA string.  Thanks to Eric MacDonald.            time=GGA(ic(Ptime-1)+1:ic(Ptime)-1); decday = -1;            if length(time)>5                decday = str2double(time(1:2))/HrPday + ...                    str2double(time(3:4))/MinPday + str2double(time(5:6))/SecPday;            end            if decday>=0 && decday<=1.2                GPStime(counter) = decday; % fraction of a day            end                        lat = GGA(ic(Plat-1)+1:ic(Plat)-1);            latH = GGA(ic(PlatH-1)+1:ic(PlatH)-1);            lon = GGA(ic(Plon-1)+1:ic(Plon)-1);            lonH = GGA(ic(PlonH-1)+1:ic(PlonH)-1);            % convert to decimal degrees            if length(lat)>3 && length(lon)>4                latn = str2double(lat(1:2)) + str2double(lat(3:end))/60;                lonn = str2double(lon(1:3)) + str2double(lon(4:end))/60;                if (latn>=0&&latn<=90) && (lonn>=0&&lonn<=180)                    GPSlat(counter) = latn * (strcmp(latH,'N')*2-1); % N>0, S<0                    GPSlon(counter) = lonn * (strcmp(lonH,'E')*2-1); % E>0, W<0                end            end        end % of valid/complete NMEA record   	    end % of potential NMEA record    LastByte = ftell(fid);    %Get the next line    line=fgetl(fid);end% In case some incomplete records were encountered:PCtimestamp=PCtimestamp(1:counter);PCfasttime=PCfasttime(1:counter); GPStime=GPStime(1:counter);GPSlat=GPSlat(1:counter);GPSlon=GPSlon(1:counter);% clear errant records (com problems, etc.)ix = find(isnan(PCtimestamp+PCfasttime+GPStime+GPSlat+GPSlon));if ~isempty(ix)    PCtimestamp(ix) = [];    PCfasttime(ix) = [];    GPStime(ix) = [];    GPSlat(ix) = [];    GPSlon(ix) = [];end% Check for change of day in GPS time (more than 2 hours backward)idel = find(diff(GPStime) < -(2/HrPday));for i=1:length(idel)    GPStime(idel(i)+1:end) = GPStime(idel(i)+1:end) + 1; % add a dayend% Given more than a few records, and PC times near UTC, assign yearday%   offset to GPS timesif length(PCtimestamp)>2    yd0 = floor(PCtimestamp(1)); % should be okay, unless very near midnight    dt0 = PCtimestamp(1)-yd0 - GPStime(1);    dte = mod(PCtimestamp(end),1) - mod(GPStime(end),1); % just in case    if abs(dt0)*MinPday < 5 || abs(dte)*MinPday < 5  % within 5 minutes        if dt0 > 0.9, yd0 = yd0 + 1; end % PC(1)<midnight<GPS(1)        if dt0 < -0.9, yd0 = yd0 - 1; end % GPS(1)<midnight<PC(1)        GPStime = GPStime + yd0;    endelseif ~isempty(PCtimestamp)    PCtimestamp=[]; PCfasttime=[];    GPStime=[]; GPSlat=[]; GPSlon=[];    disp(['Fewer than 2 valid ' NMstr ' messages in file, skipping.'])endfclose(fid);