function ADens=Read_rawADCP_EnsYday(filename)%function ADens=Read_rawADCP_EnsYday(filename)%Pass in a filename, and return structure ADens with vector fields:%  ens_no = TRDI ADCP ensemble number (from variable leader)%  RDyday = TRDI ADCP ensemble yearday (from variable leader)%  PCyday = acquisition computer timestamp (yearday type)%%  dpw - aug 2015ADens = [];[fid,message]=fopen(filename,'r');%count lines.line=fgetl(fid);counter=0;while ischar(line)     if length(findstr('T',line))==2 % two timestamps        counter=counter+1;    end    line=fgetl(fid);end%Make arrays for the answers.numrecs=counter;ADens.ens_no=zeros(1,numrecs); % ADCP ensemble number > 0ADens.RDyday=zeros(1,numrecs); % ADCP timestamp from variable leaderADens.PCyday=zeros(1,numrecs); % PC date/time that serial record was read%rewind the file.fseek(fid, 0, 'bof');%read in each lineline=fgetl(fid);counter=0;while ischar(line)    ens = -1;    try        [ens, ts] = strtok(line);        ens = str2num(ens);        [ats, ts ] = strtok(ts);        ats = datenum(ats, 'yyyymmddTHHMMSS.FFF');        ts = strtok(ts);        ts = datenum(ts, 'yyyymmddTHHMMSS.FFF');    catch        ens = -1; ats = NaN; ts = NaN;    end    % save good ones    if ens>0        counter = counter + 1;        ADens.ens_no(counter) = ens;        ADens.RDyday(counter) = ats;        ADens.PCyday(counter) = ts;    end        line=fgetl(fid);end% check that any valid records were parsedfclose(fid);if counter<1    ADens = [];    returnend% In case some incomplete records were encountered:ADens.ens_no=ADens.ens_no(1:counter);ADens.RDyday=ADens.RDyday(1:counter);ADens.PCyday=ADens.PCyday(1:counter);% convert datenums to yeardays, using year of first recordyr = datevec(ADens.PCyday(1));yrdtnum = datenum(yr(1),1,1,0,0,0);ADens.RDyday = ADens.RDyday - yrdtnum;ADens.PCyday = ADens.PCyday - yrdtnum;