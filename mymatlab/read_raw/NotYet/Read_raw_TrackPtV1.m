function [PCtimestamp,PCfasttime,SRange, Err,BrAng,DpAng] = ...    Read_raw_TrackPt(filename, ExErr)%function [PCtimestamp,PCfasttime,SRange, Err,BrAng,DpAng] = ...%   Read_raw_TrackPt(filename, ExErr)%Pass in a filename for TrackPoint data, and return row vectors of% the timestamp, elapsed time, slant range(m), and optionally error code,% bearing angle, and depression angle.% ExErr (optional) excludes records with error/low quality flags.%The files are ascii.  Dave W - Mar,2002if nargin<2 | isempty(ExErr)    ExErr = 0;endif nargout<3    error('Output to PCtimestamp,PCfasttime,SRange is required.')endoutV = [NaN, NaN, NaN];outV(1:nargout-3)=1; % optional outputs requestednVrd = min(2 + max(nargout-4,1), 4); % parse at least SRange, ErrPCtimestamp=[]; PCfasttime=[]; SRange=[]; tmpErr=[];HrPday=24; MinPday=1440; SecPday=86400;[fid,message]=fopen(filename,'r');% Field positions for two output formats [Srng; Err; BrAng; DpAng],%     don't bother parsing angles if not requested.SLmin1 = 97; % STDFPos1 = [22,28; 64,66; [16,20]*outV(2); NaN,NaN];SLmin2 = 74; % REV 4-EC (preferred format)FPos2 = [15,19; 41,43; [4,8]*outV(2); [10,13]*outV(3)];DSoff = 31; % length of prefixed date/time stampsRoff = 0; % length of anything before d/t stamps% Process valid records line=fgetl(fid);counter=0;while ischar(line)    fpos=[]; ll=length(line);    if ll >= SLmin1        fpos = FPos1 + DSoff+Roff;    elseif ll >= SLmin2 & ll<SLmin2+3        fpos = FPos2 + DSoff+Roff;    end    if ~isempty(fpos)  % valid record length        counter=counter+1;        year=str2num(line(Roff+1:Roff+4));        yday0=str2num(line(Roff+5:Roff+7)); % yearday (Jan 1 = 0.nnnn)        hour=str2num(line(Roff+8:Roff+9));        min=str2num(line(Roff+10:Roff+11));        sec=str2num(line(Roff+12:Roff+13));        PCtimestamp(counter) = yday0 + hour/HrPday + min/MinPday + sec/SecPday;        %Elapsed time next.        tmp=line(Roff+15:Roff+30); iord=[15 16 13 14 11 12 9 10 7 8 5 6 3 4 1 2];        PCfasttime(counter) = hex2num(tmp(iord));                %Parse Tracking data, save in requested vectors        ldat = NaN*ones(nVrd,1);        for ip=1:nVrd            if ~isnan(fpos(ip,1))                x = str2num( line(fpos(ip,1):fpos(ip,2)) );                if ~isempty(x), ldat(ip) = x; end            end        end        SRange(counter) = ldat(1);        tmpErr(counter) = ldat(2);        if nVrd>2            BrAng(counter) = ldat(3);            if nVrd>3                DpAng(counter) = ldat(4);            end        end    end % of valid tracking record    %Get the next line    line=fgetl(fid);end% Check for records flagged for errors or low qualityix = [];if ExErr==1  % No Good    ix = find( (tmpErr>0 & tmpErr<10) | isnan(tmpErr));elseif ExErr==2  % NG or low quality    ix = find( (tmpErr>0 & tmpErr<10) | tmpErr==64 | isnan(tmpErr));end% Exclude flagged recordsPCtimestamp(ix) = [];PCfasttime(ix) = [];SRange(ix) = [];% Optional outputsif ~isnan(outV(1)), Err = tmpErr; Err(ix)=[]; endif ~isnan(outV(2)), BrAng(ix)=[]; endif ~isnan(outV(3)), DpAng(ix)=[]; endfclose(fid);