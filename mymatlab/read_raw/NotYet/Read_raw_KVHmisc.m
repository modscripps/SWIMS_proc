function [KVHmisc]=Read_raw_KVHmisc(filename, NMstr)%function [KVHmisc]=Read_raw_KVHmisc(filename, NMstr)%Pass in a filename, and return row vectors of the PC timestamp, elapsed time,% and data vectors that are specified for the choice of NMEA-type strings% contained in the ascii file.  Default is ($)HEHDT from OPD's KVH compass,% as rendered by the SWIMS acquisition software, but this channel has also% been employed for the RV Miller's fathometer (SDDBT) and the RV Revelle's% Knudsen echosounder (PKEL99).  Output structure KVHmisc contains the specified data.% DPW - 12-Sept-2002if nargin<2 | isempty(NMstr)    NMstr = 'HEHDT';endKVHmisc = [];% Specify data names (oVars) and comma-delimited positions (ComPos) for allowed NMEA types;% Also, St2Nu has indices of straight str2num conversions.NMtag = NMstr; % actual string in recordNMok = 1; % NMEA style=1, otherwise=0switch NMstr    case 'HEHDT' % KVH        ComPos = [2]; St2Nu = [1]; oVars = {'headT'};    case 'SDDBT' % Miller's fathometer        ComPos = [4]; St2Nu = [1]; oVars = {'bot_depth'};    case 'SDDBTmv' % Melville's Knudsen, custom string        NMtag = 'SDDBT';        ComPos = [2]; St2Nu = [1]; oVars = {'bot_depth'};    case 'SDDBTch' % Cape Hatteras's Knudsen, custom string        NMtag = 'SDDBT';        ComPos = [4]; St2Nu = [1]; oVars = {'bot_depth'};    case 'SDDPT' % Thompson's Knudsen        ComPos = [2]; St2Nu = [1]; oVars = {'bot_depth'};    case 'PKEL99' % Knudsen echosounder on Revelle        ComPos = [2 3 4 5]; St2Nu = [2];        oVars = {'KnTime','bot_depth','Klat','Klon'};    case 'PKEL99Kn' % Knudsen echosounder on Knorr        NMtag = 'PKEL99';        ComPos = [2 3 5 6]; St2Nu = [1 2];        oVars = {'bot_depth','bot_depLF','Klat','Klon'}; % First depth is 12 Hz, second is 3.5 Hz    case 'PKEL99oc' % Knudsen echosounder on Oceanus        NMtag = 'PKEL99';        ComPos = [2 4 7 8]; St2Nu = [1 2];        oVars = {'bot_depth','bot_depLF','Klat','Klon'}; % First depth is 12 Hz, second is 3.5 Hz    case 'PKEL99Wec2009' % new Knudsen,software on Wecoma        NMtag = 'PKEL99';        ComPos = [2 5 6 7 8]; St2Nu = [2 3 4 5];        oVars = {'KnTime','bot_depth','Qual','Klat','Klon'};    case 'NoNmeaWec2009' % new Knudsen,software on Wecoma (errant setting)        NMtag = '12.0kHz'; NMok = 0; % no NMEA label, fill in missing with NaNs        ComPos = [2]; St2Nu = [1];        oVars = {'bot_depth','KnTime','Qual','Klat','Klon'};    otherwise        error(['Unsupported NMEA type: ' NMstr]);endif NMok    Fstr = ['$' NMtag ','];else    Fstr = [NMtag ','];endHrPday=24; MinPday=1440; SecPday=86400;[fid,message]=fopen(filename,'r');% Count lines possibly containing data.line=fgetl(fid);counter=0;while ischar(line)    igga=findstr(Fstr,line);    if ~isempty(igga) %if it's the proper NMEA string        counter=counter+1;    end    line=fgetl(fid);end%Make arrays for the answers.numrecs=counter;PCtimestamp=zeros(1,numrecs); % PC date/time that serial record was readPCelapsetime=PCtimestamp; % PC elapsed seconds since acquisition program was startedoTmp = NaN * ones(length(oVars), numrecs); % temp array to hold output vectors%rewind the file.frewind(fid);%read in each lineline=fgetl(fid);counter=0;while isstr(line)	    igga=findstr(Fstr,line);    if ~isempty(igga) && length(igga)<2 % proper NMEA record type        NMA = [line(igga(1):end) ',']; % NMA=entire NMEA record, with extra comma appended        ic=findstr(NMA,',');        if length(ic) >= max(ComPos)            counter = counter+1; % valid record            %First get the timestamp.            off=0;            year=str2num(line(off+1:off+4));            yday0=str2num(line(off+5:off+7)); % yearday (Jan 1 = 0.nnnn)            hour=str2num(line(off+8:off+9));            min=str2num(line(off+10:off+11));            sec=str2num(line(off+12:off+13));            PCtimestamp(counter) = yday0 + hour/HrPday + min/MinPday + sec/SecPday;            %Elapsed time next.            tmp=line(off+15:off+30); iord=[15 16 13 14 11 12 9 10 7 8 5 6 3 4 1 2];            PCelapsetime(counter) = hex2num(tmp(iord));                        % Parse NMEA string.            clear strTmp            for ip=1:length(ComPos)                strTmp(ip) = {''};                % find string indices for specified comma-delimited field                icb = ic(ComPos(ip)-1) + 1; ice = ic(ComPos(ip)) - 1;                if ice>=icb                    strTmp(ip) = { NMA(icb:ice) };                end            end                        % First, do easy str2num conversions            for ip=1:length(St2Nu)                icp = St2Nu(ip);                if ~isempty( strTmp{icp} ) && ~isempty(str2num(strTmp{icp}))                    oTmp(icp, counter) = str2num( strTmp{icp} );                end            end                    % Convert more complex fields to type-specific data            switch NMstr            case 'PKEL99' % Knudsen echosounder on Revelle                if ~isempty( strTmp{1} )                    xx=strTmp{1}; % time in Knudsen's serial output                    oTmp(1, counter) = str2num(xx(1:2))/HrPday + ...                        str2num(xx(3:4))/MinPday + str2num(xx(5:end))/SecPday;                end                if ~isempty( strTmp{3} )                    xx=strTmp{3}; % latitude                    sgnH = strcmp(xx(end),'N')*2 - 1; % N>0, S<0                    oTmp(3, counter) = sgnH * ( str2num(xx(1:2)) + str2num(xx(4:12))/60 );                end                if ~isempty( strTmp{4} )                    xx=strTmp{4}; % longitude                    sgnH = strcmp(xx(end-3),'E')*2 - 1; % E>0, W<0                    oTmp(4, counter) = sgnH * ( str2num(xx(1:3)) + str2num(xx(5:13))/60 );                end            case 'PKEL99Kn' % Knudsen echosounder on Knorr                if ~isempty( strTmp{3} )                    xx=strTmp{3}; % latitude                    if length(xx)>=13                        sgnH = strcmp(xx(end),'N')*2 - 1; % N>0, S<0                        yy = str2num(xx(1:2)) + str2num(xx(4:12))/60;                        if ~isempty(yy)                            oTmp(3, counter) = sgnH * yy;                        end                    end                end                if ~isempty( strTmp{4} )                    xx=strTmp{4}; % longitude                    if length(xx)>=14                        sgnH = strcmp(xx(end-3),'E')*2 - 1; % E>0, W<0                        yy = str2num(xx(1:3)) + str2num(xx(5:13))/60;                        if ~isempty(yy)                            oTmp(4, counter) = sgnH * yy;                        end                    end                end            case 'PKEL99oc' % Knudsen echosounder on Oceanus                if ~isempty( strTmp{3} )                    xx=strTmp{3}; % latitude                    if length(xx)>=13                        sgnH = strcmp(xx(end),'N')*2 - 1; % N>0, S<0                        yy = str2num(xx(1:2)) + str2num(xx(4:12))/60;                        if ~isempty(yy)                            oTmp(3, counter) = sgnH * yy;                        end                    end                end                if ~isempty( strTmp{4} )                    xx=strTmp{4}; % longitude                    if length(xx)>=14                        sgnH = strcmp(xx(end),'E')*2 - 1; % E>0, W<0                        yy = str2num(xx(1:3)) + str2num(xx(5:13))/60;                        if ~isempty(yy)                            oTmp(4, counter) = sgnH * yy;                        end                    end                end            case 'PKEL99Wec2009' % new Knudsen echosounder on Wecoma                if ~isempty( strTmp{1} )                    xx=strTmp{1}; % time in Knudsen's serial output                    oTmp(1, counter) = str2num(xx(1:2))/HrPday + ...                        str2num(xx(3:4))/MinPday + str2num(xx(5:end))/SecPday;                end            end % of switch for special strings        end % of valid/complete NMEA record   	    end % of potential NMEA record    %Get the next line    line=fgetl(fid);endfclose(fid);% In case some incomplete records were encountered:PCtimestamp=PCtimestamp(1:counter);PCelapsetime=PCelapsetime(1:counter); oTmp = oTmp(:,1:counter);% Special post-processing:switch NMstrcase {'PKEL99','PKEL99Wec2009'} % Knudsen echosounder on Revelle,Wecoma    % Check for change of day in Knudsen time (more than 2 hours backward)    idel = find(diff(oTmp(1, :)) < -(2/HrPday));    for i=1:length(idel)        oTmp(1,idel(i)+1:end) = oTmp(1,idel(i)+1:end) + 1; % add a day    end        % Given more than a few records, and PC times near UTC, assign yearday    %   offset to Knudsen times    if counter>2        yd0 = floor(PCtimestamp(1)); % should be okay, unless very near midnight        dt0 = PCtimestamp(1)-yd0 - oTmp(1,1);        dte = mod(PCtimestamp(end),1) - mod(oTmp(1,end),1); % just in case        if abs(dt0)*MinPday < 5 | abs(dte)*MinPday < 5  % within 5 minutes            if dt0 > 0.9, yd0 = yd0 + 1; end % PC(1)<midnight<Knu(1)            if dt0 < -0.9, yd0 = yd0 - 1; end % Knu(1)<midnight<PC(1)            oTmp(1,:) = oTmp(1,:) + yd0;        end    endend % of switch for special post-proc% Gather results into specified vectorsKVHmisc.PCtimestamp = PCtimestamp;KVHmisc.PCelapsetime = PCelapsetime;for ip=1:length(oVars)    KVHmisc = setfield(KVHmisc ,oVars{ip}, oTmp(ip,:) );end