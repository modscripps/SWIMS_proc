function [TrackData] = Read_raw_TrackPt(filename, ExErr, Fmt)%function [TrackData] = Read_raw_TrackPt(filename, ExErr, Fmt);%Pass in a filename for TrackPoint data, and return row vectors in % structure TrackData for the timestamp, elapsed time, slant range(m),% targer number, error code, bearing angle, and depression angle.% ExErr (optional) excludes records with error/low quality flags.% Fmt = format: 'STD', 'REV4', or 'LXT' ; if not specified, determine%      from record length (added 10/2003, dpw)%The raw files are ascii.  Dave W - Mar,2002if nargin<2 | isempty(ExErr)    ExErr = 0;endif nargin<3 | isempty(Fmt)    Fmt = [];endif ~isempty(Fmt) & ~strcmp(Fmt,'STD') & ~strcmp(Fmt,'REV4') & ~strcmp(Fmt,'LXT')    if isnumeric(Fmt)        Fmt = num2str(Fmt);    end    disp(['Read_raw_TrackPt: invalid Fmt=' Fmt '; proceeding using Fmt=[] ...'])    Fmt = [];endPCtimestamp=[]; PCfasttime=[]; SRange=[]; tmpErr=[];Targ=[]; BrAng=[]; DpAng=[];HrPday=24; MinPday=1440; SecPday=86400;[fid,message]=fopen(filename,'r');% Field positions for three output formats [Srng; Targ; Err; BrAng; DpAng],SLmin1 = 97; % STDFPos1 = [22,28; 1,1; 64,66; 16,20; NaN,NaN];SLmin2 = 74; % REV 4-EC (preferred format)FPos2 = [15,19; 1,1; 41,43; 4,8; 10,13];SLmin3 = 72; % LXT format (may be spaces after 19th char)FPos3 = [3,8; 1,1; 40,41; 10,14; 16,19];DSoff = 31; % length of prefixed date/time stampsRoff = 0; % length of anything before d/t stamps% Process valid records line=fgetl(fid);counter=0;while ischar(line)    fpos=[]; ll=length(line);    if strcmp(line(ll-1), '.') % may end with null for error code=0        line(ll+1:ll+3)='  0'; ll=ll+3;    end    if ( ll>=SLmin1 & isempty(Fmt) ) | strcmp(Fmt,'STD')        fpos = FPos1 + DSoff+Roff;    elseif ( ll>=SLmin2 & ll<SLmin2+2 & isempty(Fmt) ) | strcmp(Fmt,'REV4')        fpos = FPos2 + DSoff+Roff;    elseif ( ll>=SLmin3 & ll<SLmin3+2 & isempty(Fmt) ) | strcmp(Fmt,'LXT')        fpos = FPos3 + DSoff+Roff;    end    if ~isempty(fpos)  % valid record length        counter=counter+1;        year=str2num(line(Roff+1:Roff+4));        yday0=str2num(line(Roff+5:Roff+7)); % yearday (Jan 1 = 0.nnnn)        hour=str2num(line(Roff+8:Roff+9));        min=str2num(line(Roff+10:Roff+11));        sec=str2num(line(Roff+12:Roff+13));        PCtimestamp(counter) = yday0 + hour/HrPday + min/MinPday + sec/SecPday;        %Elapsed time next.        tmp=line(Roff+15:Roff+30); iord=[15 16 13 14 11 12 9 10 7 8 5 6 3 4 1 2];        PCfasttime(counter) = hex2num(tmp(iord));                %Parse Tracking data, save in requested vectors        ldat = NaN*ones(1,size(fpos,1));        % Make sure line length is sufficient for specified Format (Fmt)        if length(line) >= max(fpos(:,2))            for ip=1:size(fpos,1)                if ~isnan(fpos(ip,1))                    x = str2num( line(fpos(ip,1):fpos(ip,2)) );                    if ~isempty(x), ldat(ip) = x; end                end            end        end        SRange(counter) = ldat(1);        Targ(counter) = ldat(2);        tmpErr(counter) = ldat(3);        BrAng(counter) = ldat(4);        DpAng(counter) = ldat(5);    end % of valid tracking record    %Get the next line    line=fgetl(fid);end% Check for records flagged for errors or low qualityix = [];if ExErr==1  % No Good    ix = find( (tmpErr>0 & tmpErr<10) | isnan(tmpErr));elseif ExErr==2  % NG or low quality    ix = find( (tmpErr>0 & tmpErr<10) | tmpErr==64 | isnan(tmpErr));end% Exclude flagged recordsPCtimestamp(ix) = []; TrackData.PCtimestamp = PCtimestamp;PCfasttime(ix) = []; TrackData.PCelapsetime = PCfasttime;SRange(ix) = []; TrackData.SlantRange = SRange;Targ(ix) = []; TrackData.Target = Targ;Err = tmpErr; Err(ix)=[]; TrackData.ErrCode = Err;BrAng(ix)=[]; TrackData.BrgAng = BrAng;DpAng(ix)=[]; TrackData.DepAng = DpAng;fclose(fid);