%GetNewByTypeSIO.m.  %  Needs: A lot from GetNewDataSIO_func.m (Aug 2015)%    global SWIMS_cal SWIMS_config%% Already exist: iTyp,FilTyps, LocFld,MatFld,RawIndx,MatIndx,  NewData%   RawF,MatF(from index loads), iNew,iYDord,iYo,iFn,%   NewMat,MatNum,InitMat, RawFil, LastByte%   CnvCont = this many files left to process after current onedt = (now-okFLAG)*86400;if dt<0 || dt>180 || isnan(dt)    disp(['GetNewByType.m called improperly, or slow system, exiting!'])    okFLAG=NaN;    returnendpause(01)% SwimNo=2; %hardwire for now; % 7-2002, retrieve from mat_index Set_params(iSet)if exist('MatTyp', 'var')    FTYP = MatTyp; % from function GetNewData_func.m (July 2007)else    FTYP = FilTyps{iTyp}; % from scripts GetNewData_{cruise}.mendswitch FTYPcase 'CTD'    CTD = Read_rawCTsHEX_SWIMS(RawFil, SwimNo, ByteRange, year);    % disp(['CTD SWIMS ' num2str(SwimNo)])    % accumulate newly converted data    if isstruct(CTD) % keep track of last processed byte in raw file        LastByte = CTD.LastByte;    else        LastByte = NaN;    end        if isempty(NewData)        NewData = CTD;    elseif isstruct(CTD) && ...            (CTD.SWIMStime(1)-NewData.SWIMStime(end))*1440 < 1 ...            && (CTD.SWIMSfasttime(1) >= NewData.SWIMSfasttime(end))        flds = {'SWIMStime','SWIMSfasttime','tfreq','cfreq','pfreq', ...                'tfreq2','cfreq2','addata','tprCT','status','modCT'};        for i=1:length(flds)            eval(['NewData.' flds{i} '=[NewData.' flds{i} ' CTD.' flds{i} '];']);        end    else %         okFLAG = 0;        disp('Break at session end, skip this and remaining CTD files.')        CnvCont = 0;        %keyboard    end        clear CTD    % After last file is converted, compute and save pressure    %   for all new data, also convert datenums to yeardays    if ~CnvCont && ~isempty(NewData)        NewData = Sav_rawCTs_SWIMS_wPR(NewData);        % Fix up times here? - use modct,etc        YDAYmin = NewData.SWIMStime(1); YDAYmax = NewData.SWIMStime(end);    end    case 'GPS'    % [PCyday,PCfasttime,sattime,lat,lon]=Read_raw_GPS(RawFil, 'GPGGA');    GPS=Read_rawSIO_GPS(RawFil, 'GPGGA', ByteRange);        if isstruct(GPS) % keep track of last processed byte in raw file        LastByte = GPS.LastByte;    else        LastByte = NaN;    end    flds = {'PCyday','PCfasttime','sattime','lat','lon'};    if isempty(NewData) % copy to initialize        NewData = GPS;    elseif isstruct(GPS) % accumulate data        for i=1:length(flds)            NewData.(flds{i}) = [NewData.(flds{i}) GPS.(flds{i})];        end    end    clear GPS        if ~CnvCont && isstruct(NewData) % after last raw file        if ~isempty(NewData.PCyday)            YDAYmin = NewData.PCyday(1); YDAYmax = NewData.PCyday(end);        else            NewData = [];        end    endcase 'ADDN'    VelDn = Get_ADCP_SwimsDN(RawFil, -1, 1, ByteRange); % get everything        flds = {'ens_no','yday','SWIMS_headT','SWIMS_pitch','SWIMS_roll', ...            'heading','pitch','roll','btrange','bottomBT','VbtE','VbtN','VbtZ','btvel_bm', ...            'v1_bm','v2_bm','v3_bm','v4_bm', ...            'degC','depth_xducer','soundvel', ...            'ec1_bm','ec2_bm','ec3_bm','ec4_bm','cor1_bm','cor2_bm','cor3_bm','cor4_bm'};    LastByte = NaN;        if ~isempty(VelDn)        LastByte = VelDn.LastByte;        if isempty(NewData)            for i=1:length(flds)                eval(['NewData.' flds{i} '=[];']);            end            NewData.z_adcp = VelDn.z_adcp;        end%         switch lower(CrName)%             case 'mc09' % correct mis-set time, caused overlap of some ADDN data%                 if RawF.file_yday(iFn)<101 % 45 min slow, this one%                     ix = find( (VelDn.yday>98.33 & VelDn.yday<99.26 & VelDn.ens_no<6e4) | ...%                         (VelDn.yday>99.2 & VelDn.yday<99.44 & VelDn.ens_no>5.9e4) );%                     if ~isempty(ix)%                         VelDn.yday(ix) = VelDn.yday(ix) + (45/1440); %                     end%                 end%                 % Time okay, but date 4/17 misset to 4/07 (fix upper limit when clock reset)%                 if  RawF.file_yday(iFn)>106.67 && RawF.file_yday(iFn)<108.0 %                     VelDn.yday = VelDn.yday + 10;%                 end%         end        % accumulate data        for i=1:length(flds)            eval(['NewData.' flds{i} '=[NewData.' flds{i} ' VelDn.' flds{i} '];']);        end    end        clear VelDn    if ~CnvCont && ~isempty(NewData) % after last file        YDAYmin = NewData.yday(1); YDAYmax = NewData.yday(end);    end    case 'ADUP'    VelUp = Get_ADCP_SwimsUP(RawFil, -1, 1, ByteRange); % get everything    flds = {'ens_no','yday','SWIMS_headT','SWIMS_pitch','SWIMS_roll', ...            'heading','pitch','roll', ...            'v1_bm','v2_bm','v3_bm','v4_bm', ...            'degC','depth_xducer','soundvel', ...            'ec1_bm','ec2_bm','ec3_bm','ec4_bm','cor1_bm','cor2_bm','cor3_bm','cor4_bm'};    LastByte = NaN;        if ~isempty(VelUp)        LastByte = VelUp.LastByte;        if isempty(NewData)            for i=1:length(flds)                eval(['NewData.' flds{i} '=[];']);            end            NewData.z_adcp = VelUp.z_adcp;        end        % accumulate data        for i=1:length(flds)            eval(['NewData.' flds{i} '=[NewData.' flds{i} ' VelUp.' flds{i} '];']);        end    end        clear VelUp    if ~CnvCont && ~isempty(NewData) % after last file        YDAYmin = NewData.yday(1); YDAYmax = NewData.yday(end);    end    case 'LD'    LD = Read_rawSIO_WinchLine(RawFil, 'RD', ByteRange);        if isstruct(LD) % keep track of last processed byte in raw file        LastByte = LD.LastByte;    else        LastByte = NaN;    end    flds = {'PCyday','LCIyday','line_out','line_rate','TensionLbs'};    if isempty(NewData) % copy to initialize        NewData = LD;    elseif isstruct(LD) % accumulate data        for i=1:length(flds)            NewData.(flds{i}) = [NewData.(flds{i}) LD.(flds{i})];        end    end    clear LD        if ~CnvCont && isstruct(NewData) % after last raw file        if ~isempty(NewData.PCyday)            YDAYmin = NewData.PCyday(1); YDAYmax = NewData.PCyday(end);        else            NewData = [];        end    end% case 'KVH'%     switch lower(CrName) % KVH is used for various serial inputs%         case {'bs03'}%             flds = {'PCtimestamp','PCelapsetime','bot_depth','bot_depLF'};%             nma = 'PKEL99Kn'; % Knudsen echosounder, Knorr%         case {'aeg04'}%             flds = {'PCtimestamp','PCelapsetime','bot_depth','bot_depLF'};%             nma = 'PKEL99oc'; % Knudsen echosounder, Oceanus (LF was off, though)%         case {'home02'}%             flds = {'PCtimestamp','PCelapsetime','bot_depth','KnTime'};%             nma = 'PKEL99'; % Knudsen echosounder, Revelle%         case {'ps02','hc03','ml04','ps03','dec03'}%             flds = {'PCtimestamp','PCelapsetime','bot_depth'};%             nma = 'SDDBT'; % RV Miller's fathometer%         case {'philex08'}%             flds = {'PCtimestamp','PCelapsetime','bot_depth'};%             nma = 'SDDBTmv'; % Melville's Knudsen (Jason's custom str)%         case {'mc09'}%             flds = {'PCtimestamp','PCelapsetime','bot_depth','KnTime',...%                 'Qual','Klat','Klon'};%             nma = 'PKEL99Wec2009'; % Wecoma's new Knudsen%             % After using txdr for mooring releases, Knudsen string misset:%             if  RawF.file_yday(iFn)>105.958 && RawF.file_yday(iFn)<106.583%                 nma = 'NoNmeaWec2009'; % for errant setting (depth only)%             end%         case {'mort'}%             flds = {'PCtimestamp','PCelapsetime','bot_depth'};%             nma = 'SDDBTch'; % Cape Hatteras's Knudsen %         case {'wa_nliw_apr2013'}%             flds = {'PCtimestamp','PCelapsetime','bot_depth'};%             nma = 'SDDPT'; % Thompson's Knudsen%         otherwise%             flds = {'PCtimestamp','PCelapsetime','headT'};%             nma = 'HEHDT'; % KVH compass%     end%     [MISC] = Read_raw_KVHmisc(RawFil, nma);%         %     if isempty(NewData)%         for i=1:length(flds)%             eval(['NewData.' flds{i} '=[];']);%         end%     end%     % accumulate data%     if ~isempty(MISC)%         for i=1:length(flds)%             eval(['NewData.' flds{i} '=[NewData.' flds{i} ' MISC.' flds{i} '];']);%         end%     end%     clear MISC%     if ~CnvCont % after last file%         if ~isempty(NewData.PCtimestamp)%             YDAYmin = NewData.PCtimestamp(1);%             YDAYmax = NewData.PCtimestamp(end);%         else%             NewData = [];%         end%     end% case 'LT'%     flds = {'PCtimestamp','PCelapsetime','TensionLbs'};%     LT = Read_raw_ANYmisc(RawFil, 'LT');%     switch lower(CrName) % KVH is used for various serial inputs%         case {'philex08'}%             if ~isempty(LT)%                 ix = find(LT.PCtimestamp > 46.303 & ...%                     LT.PCtimestamp < 47.0 & ...%                     LT.PCelapsetime < 763000 ); % PC clock was 1 hr > UTC%                 LT.PCtimestamp(ix) = LT.PCtimestamp(ix) -1/24;%             end%     end%         %     if isempty(NewData)%         for i=1:length(flds)%             eval(['NewData.' flds{i} '=[];']);%         end%     end%     % accumulate data%     if ~isempty(LT)%         for i=1:length(flds)%             eval(['NewData.' flds{i} '=[NewData.' flds{i} ' LT.' flds{i} '];']);%         end%     end%     clear LT%     if ~CnvCont % after last file%         if ~isempty(NewData.PCtimestamp)%             YDAYmin = NewData.PCtimestamp(1);%             YDAYmax = NewData.PCtimestamp(end);%         else%             NewData = [];%         end%     end    end % of switch, and program