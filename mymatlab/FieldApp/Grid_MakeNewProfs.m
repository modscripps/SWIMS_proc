% Grid_MakeNewProfs.m -  Given yearday limits, interpolate CTD data onto depth/pressure grid%  Improvement of previous methods - Dave W, Oct 2003%  July 2007 - this routine controls updating of grid database and index,%     with Grid_MakeNewProfs_Calc.m now doing the actual gridding.if ~exist('GridStartTime','var')    disp('Cannot make new gridded profiles, GridStartTime missing')    returnendLastPrYDend = NaN;%% Find subset that these data belong to (yearday range), First passGrdF=load(GridIndx); % load fresh copyiSet = 0;for i=1:length(GrdF.Set_params)    if GrdF.Set_params(i).start_yday<GridStartTime ...            && GrdF.Set_params(i).end_yday>GridStartTime        iSet = i;        break    endendif ~iSet    disp(['GridStartTime=' num2str(GridStartTime) ...            ' is outside the bounds of Grid Index - exiting!'])    returnendGrNum = -1; % non-NaN lets Grid_MakeNewProfs_Calc.m know that gridded            %  data will be saved in indexed mat-files.            Grid_MakeNewProfs_Calc%% New profiles gridded, now add to grid files, update index;%  use NGr, GridNew, Last* returned from Grid_MakeNewProfs_Calcif isempty(NGr) % no new profiles found    returnendif GridNew    clear LastSG    LastSG.yday=[]; % Append new profiles to empty 'existing' grid    LastSG.z = NGr.z;    LastSG.p = NGr.p;    %    LastGfYDbeg = min(NGr.yday);    LastZG = NewZG;    %     x=num2str(floor(1000+LastGfYDbeg));    %     hm=datestr(mod(LastGfYDbeg,1), 15);    %     yy = num2str(GrdF.Set_params(iSet).year);    %     LastGfil = ['SWIMSgrid-' yy '-' x(2:4) '-' hm([1 2 4 5]) '.mat'];    x = datestr(LastGfYDbeg+datenum(GrdF.Set_params(iSet).year,1,1,0,0,0), ...        'yyyymmddTHHMMSS'); % revised 8/2015 for SIO type timestamp in name    LastGfil = ['SWIMSgrid-' x '.mat'];    GrNum = length(GrdF.Index(iSet).yday_beg) + 1;end%% Now append new profiles to existing grid file (empty for new file)flds = fieldnames(NGr);clear SWIMSgridiNcol = length(LastSG.yday) + [1:length(NGr.yday)]; % New profiles in these columnsfor i=1:length(flds)    if isempty(find( strcmp(flds{i}, {'z','p'}) ))        xstr = ['LastSG.' flds{i} '(:,iNcol) = NGr.' flds{i} ';'];        eval(xstr);    endend%% Next, sort by yearday, excluding any yday==NaN's (updated incomplete profiles)[yds, iyo] = sort(LastSG.yday);iex = find(isnan(yds));iyo(iex) = []; % remove incomplete profilesfor i=1:length(flds)    if isempty(find( strcmp(flds{i}, {'z','p'}) ))        xstr = ['SWIMSgrid.' flds{i} '=LastSG.' flds{i} '(:,iyo);'];        eval(xstr);    endendSWIMSgrid.z = LastSG.z; SWIMSgrid.p = LastSG.p;LastGfYDbeg = SWIMSgrid.yday(1);LastPrYDend = SWIMSgrid.yday(end) + ...    (( SWIMSgrid.ends(end)-SWIMSgrid.starts(end)+1 )/24)/86400;str={'Append','Initial'};disp(['  ' str{GridNew+1} ' SWIMSgrid.data in ' LastGfil])if IgnoreOrder    keyboardendsave( fullfile(GridFld,LastGfil), 'SWIMSgrid' );% Update, sort, and save grid index GrdF.Index(iSet).filename{GrNum} = LastGfil;GrdF.Index(iSet).yday_beg(GrNum) = LastGfYDbeg;GrdF.Index(iSet).yday_end(GrNum) = LastPrYDend;GrdF.Index(iSet).zgrid(GrNum,1:3) = LastZG;GrdF.Index(iSet).updated(GrNum) = now;% Re-sort index to yearday order[d,iOr] = sort(GrdF.Index(iSet).yday_beg);GrdF.Index(iSet).filename = GrdF.Index(iSet).filename(iOr);GrdF.Index(iSet).yday_beg = GrdF.Index(iSet).yday_beg(iOr);GrdF.Index(iSet).yday_end = GrdF.Index(iSet).yday_end(iOr);GrdF.Index(iSet).zgrid = GrdF.Index(iSet).zgrid(iOr,1:3);GrdF.Index(iSet).updated = GrdF.Index(iSet).updated(iOr);Gsv = []; Gfn = fieldnames(GrdF);for i=1:length(Gfn)    eval([Gfn{i} ' = GrdF.' Gfn{i} ';']);    Gsv = [Gsv ' ' Gfn{i}];enddisp(['  Updating ' GridIndx])if IgnoreOrder    keyboardendeval(['save ' GridIndx Gsv])eval(['clear GrdF ' Gsv])