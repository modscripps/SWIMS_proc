%GetNewByType.m.  %  Needs: A lot from GetNewData.m%    global SWIMS_cal SWIMS_config%% Already exist: iTyp,FilTyps, LocFld,MatFld,RawIndx,MatIndx,  NewData%   RawF,MatF(from index loads), iNew,iYDord,iYo,iFn, NewMat,MatNum,InitMat%   CnvCont = this many files left to process after current onedt = (now-okFLAG)*86400;if dt<0 || dt>180 || isnan(dt)    disp(['GetNewByType.m called improperly, or slow system, exiting!'])    okFLAG=NaN;    returnendpause(01)% SwimNo=2; %hardwire for now; % 7-2002, retrieve from mat_index Set_params(iSet)if exist('MatTyp', 'var')    FTYP = MatTyp; % from function GetNewData_func.m (July 2007)else    FTYP = FilTyps{iTyp}; % from scripts GetNewData_{cruise}.mendswitch FTYPcase 'CTD'    [CTD] = Read_rawCTs_SWIMS(RawFil, SwimNo);    % disp(['CTD SWIMS ' num2str(SwimNo)])    year0 = datevec(CTD.SWIMStime(1)); year0 = year0(1);    yd0 = datenum(year0, 1, 1, 0, 0, 0);    CTD.SWIMStime = CTD.SWIMStime - yd0; % convert to yeardays    % accumulate newly converted data    if isempty(NewData)        NewData = CTD;    elseif (CTD.SWIMStime(1)-NewData.SWIMStime(end))*1440 < 1 ...            && (CTD.SWIMSfasttime(1) >= NewData.SWIMSfasttime(end))        flds = {'SWIMStime','SWIMSfasttime','tfreq','cfreq','pfreq', ...                'tfreq2','cfreq2','addata','tprCT','status','modCT'};        for i=1:length(flds)            eval(['NewData.' flds{i} '=[NewData.' flds{i} ' CTD.' flds{i} '];']);        end    else %         okFLAG = 0;        disp('Break at session end, skip this and remaining CTD files.')        CnvCont = 0;        %keyboard    end        clear CTD    % After last file is converted, compute and save pressure for all new data    if ~CnvCont && ~isempty(NewData)        % smooth temp.comp. for pressure over 10 sec window        smL=min(floor(length(NewData.tprCT)/2)-2,2401);        if ~mod(smL,2), smL = smL-1; end % must be odd        smC=ones(1,smL)/smL; smH=floor(smL/2);        tprSM = conv(NewData.tprCT,smC);        tprSM(1:smH)=[]; tprSM(1:smH)=tprSM(smH+1);        tprSM(end-smH+1:end)=[]; tprSM(end-smH+1:end)=tprSM(end-smH);        [prn, xx] = GetSWIMSConfig('pr', year0, NewData.SWIMStime(1));        [Pcoefs] = read_Pcal2_sbe_swims(prn, year0, NewData.SWIMStime(1));        [TPRcoefs] = read_TPRcal_sbe_swims(prn, year0, NewData.SWIMStime(1));        % compute temp, then pressure        Tpr = TPr_Swims(tprSM, TPRcoefs.m, TPRcoefs.b);        NewData.Pr = P_sbe2(NewData.pfreq/256, Tpr, Pcoefs);        clear Tpr tprSM        % Fix up times here? - use modct,etc        YDAYmin = NewData.SWIMStime(1); YDAYmax = NewData.SWIMStime(end);    end    case 'GPS'    [PCyday,PCfasttime,sattime,lat,lon]=Read_raw_GPS(RawFil, 'GPGGA');    flds = {'PCyday','PCfasttime','sattime','lat','lon'};    if isempty(NewData)        for i=1:length(flds)            eval(['NewData.' flds{i} '=[];']);        end    end    % accumulate data    for i=1:length(flds)        eval(['NewData.' flds{i} '=[NewData.' flds{i} ' ' flds{i} '];']);        clear(flds{i})    end    if ~CnvCont % after last file        if ~isempty(NewData.PCyday)            YDAYmin = NewData.PCyday(1); YDAYmax = NewData.PCyday(end);        else            NewData = [];        end    endcase 'ADCP'    % VelVes = Get_ADCP_prof(RawFil, -1); % multi-avg_ensem per file, orig    VelVes = Get_ADCP_full(RawFil, -1, 2); % multi-avg_ensem per file, to get more - oct04    % w_wat added, 04/29/02    % pause%     flds = {'ens_no','yday','bottomBT','goodBT','u_shipBT','v_shipBT','u_wat','v_wat', ...%             'w_wat','latFP','lonFP','ldayFP','latLP','lonLP','ldayLP','heading'};    flds = {'ens_no','yday','bottomBT','goodBT','u_shipBT','v_shipBT','u_wat','v_wat', ...            'w_wat','latFP','lonFP','ldayFP','latLP','lonLP','ldayLP','heading', ...            'Nav_U','Nav_V','pg4'};    if ~isempty(VelVes)        if isempty(NewData)            for i=1:length(flds)                eval(['NewData.' flds{i} '=[];']);            end            NewData.z_adcp = VelVes.z_adcp; NewData.p_adcp = VelVes.p_adcp;        end        %         if ~isequal(NewData.z_adcp, VelVes.z_adcp)            zg = VelVes.z_adcp; zg0 = NewData.z_adcp;            zgEQ = 0;            %keyboard            if length(zg)==length(zg0) && length(zg0)>1                dg = max(diff(zg(1:2)), 1e-4); dg0 = max(diff(zg0(1:2)), 1e-4);                zz = abs(zg(1)-zg0(1)) / dg;                % check bin size and first bin depth, okay if close                if abs(dg-dg0)/dg0 < 0.01 && zz < 0.02                    zgEQ = 1; zg = zg0;                end            end            if ~zgEQ                okFLAG = 0;                disp('Depth grid changed, skipping this and remaining ADCP files.')                CnvCont = 0; clear VelVes                YDAYmin = NewData.yday(1); YDAYmax = NewData.yday(end);                return            end        end        % accumulate data        for i=1:length(flds)            eval(['NewData.' flds{i} '=[NewData.' flds{i} ' VelVes.' flds{i} '];']);        end    end        clear VelVes    if ~CnvCont && ~isempty(NewData) % after last file        YDAYmin = NewData.yday(1); YDAYmax = NewData.yday(end);    endcase 'ADDN'    %VelDn = Get_ADCP_SwimsDN(RawFil, -1); % includes profile data    %VelDn = Get_ADCP_SwimsDN_info(RawFil, -1); % excludes profile data    %flds = {'ens_no','yday','SWIMS_headT','SWIMS_pitch','SWIMS_roll', ...    %        'heading','pitch','roll','btrange','bottomBT','VbtE','VbtN','VbtZ'};    VelDn = Get_ADCP_SwimsDN(RawFil, -1, 1); % get everything        flds = {'ens_no','yday','SWIMS_headT','SWIMS_pitch','SWIMS_roll', ...            'heading','pitch','roll','btrange','bottomBT','VbtE','VbtN','VbtZ','btvel_bm', ...            'v1_bm','v2_bm','v3_bm','v4_bm', ...            'degC','depth_xducer','soundvel', ...            'ec1_bm','ec2_bm','ec3_bm','ec4_bm','cor1_bm','cor2_bm','cor3_bm','cor4_bm'};    if ~isempty(VelDn)        if isempty(NewData)            for i=1:length(flds)                eval(['NewData.' flds{i} '=[];']);            end            NewData.z_adcp = VelDn.z_adcp;        end        switch lower(CrName)            case 'mc09' % correct mis-set time, caused overlap of some ADDN data                if RawF.file_yday(iFn)<101 % 45 min slow, this one                    ix = find( (VelDn.yday>98.33 & VelDn.yday<99.26 & VelDn.ens_no<6e4) | ...                        (VelDn.yday>99.2 & VelDn.yday<99.44 & VelDn.ens_no>5.9e4) );                    if ~isempty(ix)                        VelDn.yday(ix) = VelDn.yday(ix) + (45/1440);                     end                end                % Time okay, but date 4/17 misset to 4/07 (fix upper limit when clock reset)                if  RawF.file_yday(iFn)>106.67 && RawF.file_yday(iFn)<108.0                     VelDn.yday = VelDn.yday + 10;                end        end        % accumulate data        for i=1:length(flds)            eval(['NewData.' flds{i} '=[NewData.' flds{i} ' VelDn.' flds{i} '];']);        end    end        clear VelDn    if ~CnvCont && ~isempty(NewData) % after last file        YDAYmin = NewData.yday(1); YDAYmax = NewData.yday(end);    end    case 'ADUP'    %VelUp = Get_ADCP_SwimsUP(RawFil, -1); % includes profile data    %VelUp = Get_ADCP_SwimsUP_info(RawFil, -1); % excludes profile data    %flds = {'ens_no','yday','SWIMS_headT','SWIMS_pitch','SWIMS_roll', ...    %        'heading','pitch','roll'};    VelUp = Get_ADCP_SwimsUP(RawFil, -1, 1); % get everything    flds = {'ens_no','yday','SWIMS_headT','SWIMS_pitch','SWIMS_roll', ...            'heading','pitch','roll', ...            'v1_bm','v2_bm','v3_bm','v4_bm', ...            'degC','depth_xducer','soundvel', ...            'ec1_bm','ec2_bm','ec3_bm','ec4_bm','cor1_bm','cor2_bm','cor3_bm','cor4_bm'};    if ~isempty(VelUp)        if isempty(NewData)            for i=1:length(flds)                eval(['NewData.' flds{i} '=[];']);            end            NewData.z_adcp = VelUp.z_adcp;        end        % accumulate data        for i=1:length(flds)            eval(['NewData.' flds{i} '=[NewData.' flds{i} ' VelUp.' flds{i} '];']);        end    end        clear VelUp    if ~CnvCont && ~isempty(NewData) % after last file        YDAYmin = NewData.yday(1); YDAYmax = NewData.yday(end);    end    case 'LD'    [yd, el, ld] =  Read_raw_WinchLine(RawFil);    if isempty(NewData)        NewData.yday_rate = []; NewData.eltim_rate = [];        NewData.line_rate = [];        NewData.yday_out = []; NewData.eltim_out = [];        NewData.line_out = [];    end    NewData.yday_rate = [NewData.yday_rate, yd{1}];    NewData.eltim_rate = [NewData.eltim_rate, el{1}];    NewData.line_rate = [NewData.line_rate, ld{1}];    NewData.yday_out = [NewData.yday_out, yd{2}];    NewData.eltim_out = [NewData.eltim_out, el{2}];    NewData.line_out = [NewData.line_out, ld{2}];        clear yd el ld    if ~CnvCont % after last file        if ~isempty([NewData.yday_rate, NewData.yday_out])            YDAYmin = min([NewData.yday_rate, NewData.yday_out]);            YDAYmax = max([NewData.yday_rate, NewData.yday_out]);        else            NewData = [];        end    end    case 'TD'    switch CrName        case {'ps03', 'hc03'}            [TD] = Read_raw_TrackPt(RawFil, 0, 'LXT');        otherwise            [TD] = Read_raw_TrackPt(RawFil, 2);    end    flds = {'PCtimestamp','PCelapsetime','SlantRange','Target', ...            'ErrCode','BrgAng','DepAng'};    if isempty(NewData)        for i=1:length(flds)            eval(['NewData.' flds{i} '=[];']);        end    end    % accumulate data    for i=1:length(flds)        eval(['NewData.' flds{i} '=[NewData.' flds{i} ' TD.' flds{i} '];']);    end        clear TD    if ~CnvCont % after last file        if ~isempty(NewData.PCtimestamp)            YDAYmin = NewData.PCtimestamp(1);            YDAYmax = NewData.PCtimestamp(end);        else            NewData = [];        end    endcase 'KVH'    switch lower(CrName) % KVH is used for various serial inputs        case {'bs03'}            flds = {'PCtimestamp','PCelapsetime','bot_depth','bot_depLF'};            nma = 'PKEL99Kn'; % Knudsen echosounder, Knorr        case {'aeg04'}            flds = {'PCtimestamp','PCelapsetime','bot_depth','bot_depLF'};            nma = 'PKEL99oc'; % Knudsen echosounder, Oceanus (LF was off, though)        case {'home02'}            flds = {'PCtimestamp','PCelapsetime','bot_depth','KnTime'};            nma = 'PKEL99'; % Knudsen echosounder, Revelle        case {'ps02','hc03','ml04','ps03','dec03'}            flds = {'PCtimestamp','PCelapsetime','bot_depth'};            nma = 'SDDBT'; % RV Miller's fathometer        case {'philex08'}            flds = {'PCtimestamp','PCelapsetime','bot_depth'};            nma = 'SDDBTmv'; % Melville's Knudsen (Jason's custom str)        case {'mc09'}            flds = {'PCtimestamp','PCelapsetime','bot_depth','KnTime',...                'Qual','Klat','Klon'};            nma = 'PKEL99Wec2009'; % Wecoma's new Knudsen            % After using txdr for mooring releases, Knudsen string misset:            if  RawF.file_yday(iFn)>105.958 && RawF.file_yday(iFn)<106.583                nma = 'NoNmeaWec2009'; % for errant setting (depth only)            end        case {'mort'}            flds = {'PCtimestamp','PCelapsetime','bot_depth'};            nma = 'SDDBTch'; % Cape Hatteras's Knudsen         case {'wa_nliw_apr2013'}            flds = {'PCtimestamp','PCelapsetime','bot_depth'};            nma = 'SDDPT'; % Thompson's Knudsen        otherwise            flds = {'PCtimestamp','PCelapsetime','headT'};            nma = 'HEHDT'; % KVH compass    end    [MISC] = Read_raw_KVHmisc(RawFil, nma);            if isempty(NewData)        for i=1:length(flds)            eval(['NewData.' flds{i} '=[];']);        end    end    % accumulate data    if ~isempty(MISC)        for i=1:length(flds)            eval(['NewData.' flds{i} '=[NewData.' flds{i} ' MISC.' flds{i} '];']);        end    end    clear MISC    if ~CnvCont % after last file        if ~isempty(NewData.PCtimestamp)            YDAYmin = NewData.PCtimestamp(1);            YDAYmax = NewData.PCtimestamp(end);        else            NewData = [];        end    endcase 'LT'    flds = {'PCtimestamp','PCelapsetime','TensionLbs'};    LT = Read_raw_ANYmisc(RawFil, 'LT');    switch lower(CrName) % KVH is used for various serial inputs        case {'philex08'}            if ~isempty(LT)                ix = find(LT.PCtimestamp > 46.303 & ...                    LT.PCtimestamp < 47.0 & ...                    LT.PCelapsetime < 763000 ); % PC clock was 1 hr > UTC                LT.PCtimestamp(ix) = LT.PCtimestamp(ix) -1/24;            end    end            if isempty(NewData)        for i=1:length(flds)            eval(['NewData.' flds{i} '=[];']);        end    end    % accumulate data    if ~isempty(LT)        for i=1:length(flds)            eval(['NewData.' flds{i} '=[NewData.' flds{i} ' LT.' flds{i} '];']);        end    end    clear LT    if ~CnvCont % after last file        if ~isempty(NewData.PCtimestamp)            YDAYmin = NewData.PCtimestamp(1);            YDAYmax = NewData.PCtimestamp(end);        else            NewData = [];        end    end    end % of switch, and program