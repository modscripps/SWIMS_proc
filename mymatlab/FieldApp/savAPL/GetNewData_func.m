function Dout = GetNewData_func(cruz, Cst)%Get the new data.  If the Load Local button was pressed, then get the stuff%out of the files already present.%  Needs: savepath, remotepath (ETC), localpath,%    global SWIMS_cal SWIMS_configcrz=cruz;set_swims_pathscruise=cruz;savepath=[]; % to distinguish from Matlab functionSWIMSfoldersPC% Later: Input structure Cst:  which data types to copy, map of%  raw types to mat types, which types to convert to mat files,%  MatHrs(cutoff for mat files), etc???Dout.NewCtdFLG = 0; % to pass info on whether to grid more CTD dataDout.Error = NaN;RawCopyTyps = {'CTD','GPS','LD','KVH', 'LT','ADDN','ADUP'}; % Raw Types to copyRawConvTyps = {'CTD','GPS','LD','KVH', 'LT','ADDN','ADUP'}; % Raw Types to convert to matlabRawsToMats = {'CTD','CTD'; 'GPS','GPS'; 'LD','LD'; ...    'ADDN','ADDN'; 'ADUP','ADUP'; 'KVH','KVH'; 'LT','LT'};MatHrs = 2.5-0.5; % Start new matlab file after this many hours accumulatedIndFld = fullfile(savepath, 'indexes'); % raw,matlab data index folderCrName = cruz;%%%%%%%%%%%%% (1) Find new raw files, copy into local folders %%%%%%%%%%%for iTyp = 1:length(RawCopyTyps)    RemFld = fullfile(remotepath, RawCopyTyps{iTyp}); % on Acq machine    % RemFld = remotepathETC; % on 2nd Acq machine    %RemFld = fullfile(remotepath, RawCopyTyps{iTyp}); % if each has subfolder    LocFld = fullfile(localpath, RawCopyTyps{iTyp});    RawIndx = fullfile(IndFld, [RawCopyTyps{iTyp} '_' CrName '_rawfiles.mat']);    disp(['Copy new ' RawCopyTyps{iTyp} ' raw data files, ' datestr(now,13) '...'])    if ~exist(RemFld)        disp([' **Remote folder not found:  ' RemFld])        continue    end    filelist = SaveNewFiles(RemFld, LocFld, [RawCopyTyps{iTyp} '-'], RawIndx);    Dout.RawCopy.(RawCopyTyps{iTyp}) = filelist;    disp(' ')end%%%%%%%%%%%%% (2) Convert raw files to matlab files, update raw,mat index%%%%%%%%%%%%% %%%%%%%%%%%RawConvTyps = {'CTD','GPS','LD','LT','ADDN','ADUP'};Dout.AnyUpdate = 0; % To return flag that some files/indexes were alteredfor iTyp = 1:length(RawConvTyps)    LocFld = fullfile(localpath, RawConvTyps{iTyp}); % local raw directory    % get corresponding matlab type    id = strmatch(RawConvTyps{iTyp}, RawsToMats(:,1), 'exact');    if isempty(id)        disp(['No matlab type defined for raw ' RawConvTyps{iTyp}])        continue    end    MatTyp = RawsToMats{id,2};    MatFld = fullfile(savepath,'data_mat',MatTyp); % local mat directory    RawIndx = fullfile(IndFld, [RawConvTyps{iTyp} '_' CrName '_rawfiles.mat']);    MatIndx = fullfile(IndFld, [MatTyp '_' CrName '_matfiles.mat']);    clear RawF file_name file_yday file_status file_copied % raw index    clear MatF Cruise Set_params Index PROG % matlab index (stage 1 processing)    CnvCont=0;    disp(['Convert ' RawConvTyps{iTyp} ' to ' MatTyp '.mat, ' datestr(now,13) '...'])    %% Check for recently copied files that are ready to convert    if ~exist(RawIndx,'file') || ~exist(MatIndx,'file')        disp('  Cannot find index into raw or matlab files, skipping!')    else        RawF=load(RawIndx); MatF=load(MatIndx);        % Check that files are in local directory, skip empty ones        iNew = find(RawF.file_status==0);        %%% BS03:  Moved pre-yday091 raw files to another set of folders to speed processing:        %iNew = find(RawF.file_status==0 & RawF.file_yday>91.0); % avoids 'absent' raw files        Fydays = [];        for i=1:length(iNew)            dd = dir( fullfile(LocFld, RawF.file_name{iNew(i)} ) );            Fydays(i) = RawF.file_yday(iNew(i));            if length(dd)<1                iNew(i) = NaN; % raw file not in local folder            elseif dd(1).bytes < 1                iNew(i) = -iNew(i); % zero-sized, don't process            end        end        imis = length(find(isnan(iNew)));        if imis>0            disp(['  Some (' num2str(imis) ') raw files not in ' LocFld ...                ', skipping all!!'])        else            % Count potential files to convert (nonempty, for one matlab set only)            CnvCont = length( find(iNew>0) );            if ~CnvCont                disp('  Found no unconverted files.')            end        end    end % of checking raw index, now do conversions    %% Convert only those files that belong in a single matlab file    Dout.RawConvCt.(RawConvTyps{iTyp}) = CnvCont; % potential    if CnvCont>0        % Find which subset the resulting matlab file will belong to;        %  if files cross set boundary, wait until next time for latter ones.        iSet = 0; FstYD = 0; SwimNo = NaN;        [x, iYDord] = sort(Fydays); % process in date/time order        for iYo=1:length(iYDord)            iFn = iNew( iYDord(iYo) ); % index number in raw index            if iFn > 0 % skip empty ones                Ryd = RawF.file_yday(iFn); % from filename timestamp                sn = 0;                for i=1:length(MatF.Set_params)                    if MatF.Set_params(i).start_yday<Ryd ...                            && MatF.Set_params(i).end_yday>Ryd                        sn = i;                        break                    end                end                if ~iSet                    iSet = sn; % First non-empty file determines set#                    SwimNo = MatF.Set_params(sn).SWIMS_num;                    FstYD = Ryd; % date/time of first raw file                elseif sn~=iSet || (Ryd-FstYD)*24 > MatHrs                    % if more than MatHrs hrs (default=2) or new set#, skip til next time                    iNew( iYDord(iYo) ) = 0;                end            end        end % of checking for set#, time range        CnvCont = length( find(iNew>0) ); % re-count, excluding those for later        Dout.RawConvCt.(RawConvTyps{iTyp})(2) = CnvCont; % attempted        disp(['     Found ' num2str(CnvCont) ' files to convert ...'])        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        %%%%%%%% Ready to accumulate and save new data, update indexes %%%%%%%        %% Convert raw files into matlab data, accumulate all new data (by type)        clear NewData        NewData = []; % structure for gathering new matlab data        RawFil_0 = []; % name of first processed raw file        for iYo=1:length(iYDord)            iFn = iNew( iYDord(iYo) ); % index number in raw index            if iFn > 0 % process non-empty raw files                RawFil = fullfile(LocFld, RawF.file_name{iFn});                if isempty(RawFil_0)                    RawFil_0 = RawF.file_name{iFn}; % might use for new mat-file                end                disp(['   ' num2str(CnvCont) '. ' RawF.file_name{iFn} ])                okFLAG = now; % safety flag for following:                CnvCont = CnvCont-1;                GetNewByType; % separate script for clarity (??)                if isnan(okFLAG)                    disp('PROBLEM converting files, STOP but try later !!')                    clear NewData                    Dout.Error = -1;                    return                elseif ~okFLAG                    % EG, found ADCP depth grid change, or new CTD logging session                    break % to exclude current file and stop                else                    RawF.file_status(iFn) = 1;                end            elseif iFn < 0 % just flag index for empty ones                RawF.file_status(-iFn) = 1;            end        end        % Check whether any data were actually found        if isempty(NewData)            disp('    No valid data of this type were found.')            %% update Rawfile index -> processed            Rsv = []; Rfn = fieldnames(RawF);            for i=1:length(Rfn)                eval([Rfn{i} ' = RawF.' Rfn{i} ';']);                Rsv = [Rsv ' ' Rfn{i}];            end            disp(['     But, update ' RawIndx])            eval(['save ' RawIndx Rsv])            eval(['clear RawF ' Rsv])            clear MatF            % Flag that Raw index was updated (no data conversions, though)            Dout.AnyUpdate = Dout.AnyUpdate + sqrt(-1);            continue        end        %% New data are ready, find/create proper matlab file for storage        MatNum = length(MatF.Index(iSet).yday_beg); % latest matlab file        NewMat = 0; %% default = add to latest existing file        % Determine matlab file for saving data        if ~MatNum            NewMat = 1; MatNum = 1; % will be first one for subset        elseif ~exist(fullfile(MatFld, MatF.Index(iSet).filename{MatNum}), 'file')            NewMat = 1; MatNum = MatNum + 1; % start a fresh matlab file        elseif (YDAYmin - MatF.Index(iSet).yday_beg(MatNum))*24 > MatHrs            NewMat = 2; MatNum = MatNum + 1; % time for a new matlab file        end        % Load existing file to append (NewMat=0) or check (CTD,NewMat=2)        if ~NewMat            load( fullfile(MatFld, MatF.Index(iSet).filename{MatNum}) )        elseif NewMat==2 && ( strcmp(MatTyp,'CTD') )            load( fullfile(MatFld, MatF.Index(iSet).filename{MatNum-1}) )        end        % Special considerations for starting new file/info        CTDyd_0 = 0;        if strcmp(MatTyp,'CTD') && NewMat~=1            % CTD notes origin for elasped seconds (SWIMSfasttime),            %  which is yearday that acquisition session started            newSes =  (NewData.SWIMStime(1)-SWraw.SWIMStime(end))*1440 > 1 ...                | (NewData.SWIMSfasttime(1) < SWraw.SWIMSfasttime(end));            Dout.NewCtdFLG = 1;            if newSes, Dout.NewCtdFLG = -1; end            if ~NewMat && newSes % Session changed before new files                NewMat = 1; MatNum = MatNum + 1; CTDyd_0 = 0;            elseif NewMat==2 && ~newSes  % Retain previous file's time origin                CTDyd_0 = SWraw.FastTime_Origin;            end        elseif strcmp(MatTyp,'ADCP') && ~NewMat            % Check whether New ADCP (Vessel) data has different depth grid            if ~isequal(NewData.z_adcp, Vel.z_adcp)                NewMat = 1; MatNum = MatNum + 1; % start new matlab file            end        end        % Structure name and fields for saving data        switch MatTyp            case 'CTD'                MatSTR = 'SWraw';                flds = {'SWIMStime','SWIMSfasttime','tfreq','cfreq','pfreq', ...                    'tfreq2','cfreq2','addata','tprCT','status','modCT','Pr'};                if NewMat  % compute new time origin, or retain previous file's                    if ~CTDyd_0                        CTDyd_0 = NewData.SWIMStime(1) ...                            - NewData.SWIMSfasttime(1)/86400;                    end                    NewData.FastTime_Origin = CTDyd_0;                end            case 'GPS'                MatSTR = 'GPS';                flds = {'PCyday','PCfasttime','sattime','lat','lon'};            case 'ADCP'                MatSTR = 'Vel';                flds = {'ens_no','yday','bottomBT','goodBT','u_shipBT','v_shipBT','u_wat','v_wat', ...                    'w_wat','latFP','lonFP','ldayFP','latLP','lonLP','ldayLP','heading'};            case 'ADDN'                MatSTR = 'ADDN';                %             flds = {'ens_no','yday','SWIMS_headT','SWIMS_pitch','SWIMS_roll', ...                %                     'heading','pitch','roll','btrange','bottomBT','VbtE','VbtN','VbtZ'};                flds = {'ens_no','yday','SWIMS_headT','SWIMS_pitch','SWIMS_roll', ...                    'heading','pitch','roll','btrange','bottomBT','VbtE','VbtN','VbtZ','btvel_bm', ...                    'v1_bm','v2_bm','v3_bm','v4_bm', ...                    'degC','depth_xducer','soundvel', ...                    'ec1_bm','ec2_bm','ec3_bm','ec4_bm','cor1_bm','cor2_bm','cor3_bm','cor4_bm'};            case 'ADUP'                MatSTR = 'ADUP';                %             flds = {'ens_no','yday','SWIMS_headT','SWIMS_pitch','SWIMS_roll', ...                %                     'heading','pitch','roll'};                flds = {'ens_no','yday','SWIMS_headT','SWIMS_pitch','SWIMS_roll', ...                    'heading','pitch','roll', ...                    'v1_bm','v2_bm','v3_bm','v4_bm', ...                    'degC','depth_xducer','soundvel', ...                    'ec1_bm','ec2_bm','ec3_bm','ec4_bm','cor1_bm','cor2_bm','cor3_bm','cor4_bm'};            case 'LD'                MatSTR = 'LD';                flds = {'yday_rate','eltim_rate','line_rate', ...                    'yday_out','eltim_out','line_out'};            case 'TD'                MatSTR = 'TD';                flds = {'PCtimestamp','PCelapsetime','SlantRange','Target', ...                    'ErrCode','BrgAng','DepAng'};            case 'KVH'                MatSTR = 'KVH';                switch lower(CrName) % KVH is used for various serial inputs                    case {'bs03'} % Knudsen echosounder (Knorr format)                        flds = {'PCtimestamp','PCelapsetime','bot_depth','bot_depLF'};                    case {'home02'} % Knudsen echosounder                        flds = {'PCtimestamp','PCelapsetime','bot_depth','KnTime'};                    case {'ps02','hc03','ml04','philex08','mort','wa_nliw_apr2013'}                        % RV Miller's fathometer, and basic Knudsen                        flds = {'PCtimestamp','PCelapsetime','bot_depth'};                    case {'mc09'}                        flds = {'PCtimestamp','PCelapsetime','bot_depth','KnTime',...                            'Qual','Klat','Klon'};                    otherwise % KVH compass                        flds = {'PCtimestamp','PCelapsetime','headT'};                end            case 'LT'                MatSTR = 'LT';                flds = {'PCtimestamp','PCelapsetime','TensionLbs'};        end        %% Initiate or accumulate:        if NewMat            clear(MatSTR)            eval([MatSTR ' = NewData;'])        else            for i=1:length(flds)                xstr = [MatSTR '.' flds{i} ...                    '=[' MatSTR '.' flds{i} ' NewData.' flds{i} '];'];                eval(xstr);            end        end        clear NewData        %%% Data are ready for saving        if NewMat            MatFil = [RawFil_0 '.mat'];            MatF.Index(iSet).filename{MatNum} = MatFil;            MatF.Index(iSet).yday_beg(MatNum) = YDAYmin;            MatF.Index(iSet).yday_end(MatNum) = YDAYmax;        else            MatFil = MatF.Index(iSet).filename{MatNum};            if YDAYmin < MatF.Index(iSet).yday_end(MatNum)                disp(['YDAYmin(new) < yday_end in ' MatFil])            end            if YDAYmin < MatF.Index(iSet).yday_beg(MatNum)                disp(['YDAYmin(new) < yday_start in ' MatFil])                MatF.Index(iSet).yday_beg(MatNum) = YDAYmin;            end            if YDAYmax > MatF.Index(iSet).yday_end(MatNum)                MatF.Index(iSet).yday_end(MatNum) = YDAYmax;            end        end        %% Save new/updated matlab file of converted raw data        disp(['  Saving ' MatSTR '.data in ' MatFil])        save(fullfile(MatFld, MatFil), MatSTR);        clear(MatSTR)        %% update Rawfile index -> processed        Rsv = []; Rfn = fieldnames(RawF);        for i=1:length(Rfn)            eval([Rfn{i} ' = RawF.' Rfn{i} ';']);            Rsv = [Rsv ' ' Rfn{i}];        end        % disp(['  Updating ' RawIndx])        eval(['save ' RawIndx Rsv])        eval(['clear RawF ' Rsv])        %% update Matlab file index -> converted data saved        Msv = []; Mfn = fieldnames(MatF);        % Re-sort index to yearday order        [d,iOr] = sort(MatF.Index(iSet).yday_beg);        MatF.Index(iSet).filename = MatF.Index(iSet).filename(iOr);        MatF.Index(iSet).yday_beg = MatF.Index(iSet).yday_beg(iOr);        MatF.Index(iSet).yday_end = MatF.Index(iSet).yday_end(iOr);        for i=1:length(Mfn)            eval([Mfn{i} ' = MatF.' Mfn{i} ';']);            Msv = [Msv ' ' Mfn{i}];        end        % disp(['  Updating ' MatIndx])        eval(['save ' MatIndx Msv])        eval(['clear MatF ' Msv])        Dout.AnyUpdate = Dout.AnyUpdate + 1; % Matlab data files and indexes updated    end % of portion for converting any unprocessed raw files (if CnvCont>0)    clear MatF RawF % in case no unprocessed files were foundend % of loop: for iTyp=1:endDout.Error = 0;