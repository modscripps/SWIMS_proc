function Sout = Swims_Update_Gui(Sin)% Swims_Update.m - Copy raw files, convert to matlab data, update CTD grid.%  This 'automates' the process - Dave WCRZ = 'ARCTIC2015';% Later, could specify which Raw types to copy, which to convert, and%   how they map to Matlab types: Sin.*typ = questdlg('Output Message Handling:',...    ['Initiate SWIMS Processing (' CRZ ')'], ...    'Suppressed','Command Window','Abort Processing', ...    'Suppressed');switch typ    case 'Suppressed'        OutTYP = 0;    case 'Command Window'        OutTYP = 1;    otherwise % including 'Abort Processing'        disp('SWIMS Processing NOT STARTED!')        returnend        x=now; ts=datestr(x,13); dt=datevec(x); yr=dt(1);yds = num2str( 1000 + yearday(dt(3),dt(2),yr,0,0,0) );fext = [num2str(yr) '-' yds(2:4) '-' ts([1 2 4 5])];OutFILE = ['SwimsUpdate-' fext];if OutTYP    diary(OutFILE)    disp(['Okay, starting (diary logging in ' OutFILE ') ... '])else    disp(['Okay, starting (output logging in ' OutFILE ') ... '])    fid = fopen(OutFILE,'a');    if fid<0        disp('## Cannot open output file, messages may be lost ##')    end    if fid>0        fclose(fid);    endendLGyd = 'unknown'; % yearday of last gridded CTDCont = 1;while Cont>0 % Execute, pause loop        NewCtdFLG = 0; % disable gridding until ready    DoMore = 1;    while DoMore % Copy,Conversion loop        clear GetNewData_func % in case of adjustments        clear DD        hw = waitbar(.50,'Copying and Converting Files...', ...            'Name','SWIMS Processing');        % Copy new files from acquisition system, convert to Matlab data.        if OutTYP            DD = GetNewData_func(CRZ);        else            try                clear TXT                [TXT, DD] = evalc('GetNewData_func(CRZ)');                fid = fopen(OutFILE,'a');                if fid>0                    fprintf(fid,'%s',TXT);                    fclose(fid);                end                clear TXT            catch                errmsg = lasterr;                disp(['Problem with GetNewData_func: ' errmsg])            end        end        close(hw)        % If any new CTD data, then ...        if DD.NewCtdFLG            NewCtdFLG = 1;        end        DoMore = 0; % check if some are pending for conversion        if isfield(DD,'RawConvCt')            fns = fieldnames(DD.RawConvCt);            for i=1:length(fns)                if length(DD.RawConvCt.(fns{i}))>1                    if diff(DD.RawConvCt.(fns{i})(1:2)) < 0                        DoMore = 1; % some are pending                    end                end            end        end    end % of copy,conversion loop        % Grid any new CTD data    if NewCtdFLG % && 0        clear DD        hw = waitbar(0.67,'Gridding new CTD data...', ...            'Name','SWIMS Processing');        if OutTYP            DD = Grid_RunNewProfs_func(CRZ);        else            try                clear TXT                [TXT,DD] = evalc('Grid_RunNewProfs_func(CRZ)');                fid = fopen(OutFILE,'a');                if fid>0                    fprintf(fid,'%s',TXT);                    fclose(fid);                end                clear TXT            catch                errmsg = lasterr;                disp(['Problem with Grid_RunNewProfs_func: ' errmsg])            end        end        if isfield(DD,'Gridded') && DD.Gridded>0            LGyd = num2str(DD.Gridded);        end        close(hw)    end % of gridding new CTD data        % Pause before next execution    if OutTYP        disp(' ')    end    SWPfil = 'Swims_Update_param.mat';    if exist(SWPfil, 'file')        clear SWP        SWP = load(SWPfil);        psec = SWP.pause_secs;        if isempty(psec) || psec<30            psec = 30;        end        clear SWP    else        psec = 300;    end        Cont=1; % by default        bstr = ['Pausing until ' datestr(now+psec/86400, 13)];    if OutTYP        disp([bstr ' ... '])    end    nsec = 5;    if psec>60        nsec = 10;    end    tsec = ceil(psec/nsec);        %% Use WaitBar to allow interruption of regular pause period    hw = waitbar(0,bstr, 'Name',['SWIMS Processing (last gridded=' LGyd ')'], ...        'CreateCancelBtn','set(gcf,''UserData'',1);');    for isec=1:tsec        ct = 0;        waitbar(isec/tsec)        ct = get(hw,'UserData'); % by pressing 'Cancel' in WaitBar figure        if ct > 0            closereq            if OutTYP                disp('%% Interrupt Pressed %%')            end            typ = questdlg('Select Action:','SWIMS Processing Interrupt',...                'Run Immediately','Select New Delay','Exit Processing', ...                'Run Immediately');%             closereq%             commandwindow            switch(typ)                case 'Exit Processing'                    disp('Okay, exiting -- use Swims_Update_Gui to resume.')                    disp( datestr(now+psec/86400, 13) )                    Cont = 0; % stops further processing                case 'Select New Delay'                    dx = int2str(psec);                    xx = inputdlg({'Enter New Delay, seconds'},...                        'Swims_Update control',1,{dx});                    if isempty(xx)                        xx = psec;                    else                        xx = str2num(xx{1});                        if isempty(xx) || xx<30                            if OutTYP                                disp('Too short < 30, not changed')                            end                            xx = psec;                        end                    end                    psec = xx;                    %% Update parameter file                    clear SWP                    if exist(SWPfil, 'file')                        clear SWP                        SWP = load(SWPfil);                    end                    SWP.pause_secs = psec;                    Psv = []; Pfn = fieldnames(SWP);                    for i=1:length(Pfn)                        eval([Pfn{i} ' = SWP.' Pfn{i} ';']);                        Psv = [Psv ' ' Pfn{i}];                    end                    eval(['save ' SWPfil Psv])                    eval(['clear SWPF ' Psv])                    if OutTYP                        disp(['Delay now = ' int2str(psec) ' sec; But run immediately ...'])                    end                otherwise                    % including 'Run Immediately'                    if OutTYP                        disp(['Okay, run now (delay interval remains ' int2str(psec) ' s) ...'])                    end            end % of switch for action to take                        break  % out of pause loop        end        pause(nsec)        if isec==tsec            closereq; % Ready to run processing after current delay period        end    end % of pause loop, checking for interrupts in WaitBar figure    endSout.End_time = now;diary off