% Grid_FindNewProfs.m -  Check for updated raw CTD (matlab) data; Find yearday limits%  for new Down/Up profiles based on Winch Line Data; Add profiles to Gridded Data.%  Improvement of previous methods - Dave W, Oct 2003Prof_Ydays = []; %% Cell Array with yearday limits of CTD profiles.%% Cell is indexed to coincide with yearday-ranges of CTD matlab data files% check for limits specified in input argument to Grid_RunNewProfs_func.mif isstruct(Cst) && isfield(Cst,'YLIMS')    Prof_Ydays{1} = Cst.YLIMS;  % must do carefully, no error checking    disp('got it!')    returnend%% Check for YearDay ranges of un-Gridded CTD datalyday = []; % check for last profile, and/or start of new datanSet = length(GrdF.Set_params);for iSet = nSet:-1:1    if ~isempty(GrdF.Index(iSet).yday_beg)        load( fullfile(GridFld, GrdF.Index(iSet).filename{end}) )        lyday(end+1) = max(SWIMSgrid.yday);        clear SWIMSgrid        break; % found last (by yday) gridded profile    else % nominal start of new data (maybe new 'set')        lyday(end+1) = (GrdF.Set_params(iSet).start_yday + 2/1440) * -1;    endendx=clock; % Don't try to look past current date/timeYDay_max = datenum(now) - datenum(x(1), 1, 1, 0, 0, 1);if YDay_max < abs(lyday(end)) || x(1)>year    YDay_max = 1000; % current year is not when data were takenendYDay_end = min(GrdF.Set_params(iSet).end_yday, YDay_max);YDay_beg = abs(lyday(end));if length(lyday)>1 && abs(lyday(end-1))<YDay_max    % Next 'Set', if finishing off griddable CTD data from previous Set    YDay_end(2) = min(GrdF.Set_params(iSet+1).end_yday, YDay_max);    YDay_beg(2) = abs(lyday(end-1));end% Search nominal yearday ranges for Specific YearDay's of un-gridded dataclear SP LDYDLims = [];for iPd=1:length(YDay_beg)    yd_b = YDay_beg(iPd);     chk_go = 1; % keep checking for new data    while chk_go        yd_e = [];        for iCt=1:length(CtdF.Index);            % find at least 10 seconds of data            ix = find( yd_b+(10/86400) < CtdF.Index(iCt).yday_end & ...                YDay_end(iPd)-(10/86400) > CtdF.Index(iCt).yday_beg );            if ~isempty(ix)                % stop at end of CTD file, if in range                yd_e = min( CtdF.Index(iCt).yday_end(ix(1)), YDay_end(iPd) );                % begin at start of CTD file, if there is a gap after last interval                yd_b = max( yd_b, CtdF.Index(iCt).yday_beg(ix(1)) );                yd_b = min( yd_b, yd_e-2/86400 ); % just in case                break            end        end        % Accumulate data intervals (Corresponding to partial/complete CTD matlab files)        if ~isempty(yd_e)            YDLims = [YDLims; [yd_b, yd_e] ];            yd_b = yd_e + (5/86400); % start of next potential chunk of data            % (short gap of 5 sec will be overlapped when finding profiles)        else            chk_go = 0; % No more data for this nominal range        end    end    % Go on to second nominal range (new Set), if presentend % Done finding new data intervals (YDLims)if isempty(YDLims)    % No new data found    returnend%% Now, examine intervals for new profiles to gridclear Prof_Ydaysfor iPd=1:length(YDLims(:,1))    Prof_Ydays{iPd} = [];    % Start 1 minute before beginning of last gridded profile    %  (which may have been incomplete, if some data were unavailable)    yd_b = YDLims(iPd,1) - (1/1440); yd_e = YDLims(iPd,2);    % Check last pending profile from previous interval (if contiguous)    if iPd>1 && (YDLims(iPd,1)-YDLims(iPd-1,2))<(1/1440) && ~isempty(Prof_Ydays{iPd-1})        yd_b = Prof_Ydays{iPd-1};        yd_b = yd_b(1,end) - (1/1440); % to re-check last pending profile    end    CRaw = get_SWIMS_RawData(yd_b, yd_e, MatIndx, MatFld, 1);    if ProfByLine        % Use Line Data to define profiles%       LDat = get_WinchLine_data(yd_b, yd_e, LinIndx, LinFld, 1);        LDat = get_WinchLineSIO_data(yd_b, yd_e, LinIndx, LinFld, 1); % Aug 2015        if ~isempty(LDat) && ~isempty(CRaw)            LinLims = find_profiles_LineOut(LDat);            if ~isempty(LinLims)                Lprb = nonmoninterp1(CRaw.yday_adj, CRaw.Pr, LinLims.yday_beg);                Lpre = nonmoninterp1(CRaw.yday_adj, CRaw.Pr, LinLims.yday_end);%                 Lprb = interp1(CRaw.yday_adj, CRaw.Pr, LinLims.yday_beg, 'linear', NaN);%                 Lpre = interp1(CRaw.yday_adj, CRaw.Pr, LinLims.yday_end, 'linear', NaN);                % skip short profiles, esp near surface;                % 2015: check by dbar, not MPa                ix = find( (Lprb<20 & Lpre<20) | abs(Lprb-Lpre)<15 | isnan(Lprb+Lpre)); % PROFILE threshold                %ix = find( (Lprb<0.2 & Lpre<0.20) | abs(Lprb-Lpre)<0.15 | isnan(Lprb+Lpre));                %ix = find( (Lprb<0.07 & Lpre<0.10) | abs(Lprb-Lpre)<0.07 | isnan(Lprb+Lpre));                % clear short or near-surface activity (deploying/retrieving)                Lprb(ix) = []; Lpre(ix) = [];                LinLims.yday_beg(ix) = []; LinLims.yday_end(ix) = [];                LinLims.type(ix) = [];                if ~isempty(Lprb) % Some profiles with CTD data were found                    Prof_Ydays{iPd} = [LinLims.yday_beg; LinLims.yday_end; LinLims.type];                end            end        end    else        % Use pressure record to define profiles%         % Newer method: problems with pressure reversals, but good at ends%         ProLims = find_Swims_profiles(CRaw.Pr(IND)', CRaw.yday_adj(IND)');%         if ~isempty(ProLims)%             Prof_Ydays{iPd} = [ProLims.yday_beg'; ProLims.yday_end'; ProLims.type'];%         end        % Older method: smooths over pressure reversals, but yields extra near surface        disp('Finding profiles by pressure reversals NOT implemented!')        keyboard        [indS,indF,UD,bf] = get_profiles(CRaw.Pr', CRaw.yday_adj', 24);        if ~isempty(indS)            Prof_Ydays{iPd} = [CRaw.yday_adj(indS); CRaw.yday_adj(indF); UD];        end    end    clear LDat LinLims CRaw indS indF UD bfendreturn%% plot profiles to check algorithmcc=['rm';'gc';'kb'];for i=1:length(Prof_Ydays)    kc=mod(i,2)+1;    plims = Prof_Ydays{i};    if ~isempty(plims)        CRaw = get_SWIMS_RawData(plims(1,1)-5/1440, plims(2,end)+5/1440, MatIndx, MatFld, 1);        plot(CRaw.yday_adj(1:24:end), CRaw.Pr(1:24:end), [cc(3,kc) '.']);        hold on, axis ij        pb = interp1(CRaw.yday_adj, CRaw.Pr, plims(1,:));        pe = interp1(CRaw.yday_adj, CRaw.Pr, plims(2,:));        for ip=1:length(pb)            ud=2;            if ~(plims(3,ip)>0)                ud=1; % DOWN, or any not UP            end            plot(plims(1:2,ip),[pb(ip);pe(ip)], [cc(ud,kc) '-'], ...                plims(1:2,ip),[pb(ip);pe(ip)], [cc(3,kc) 'o'])        end        % keyboard    endend