% Grid_MakeNewProfs_Calc.m -  Given yearday limits, interpolate CTD data%  onto depth/pressure grid%  Improvement of previous methods - Dave W, Oct 2003%  July 2007: split actual computation into Grid_MakeNewProfs_Calc.m,%     with saving into Grid files and updating Index occuring in%     Grid_MakeNewProfs.m -- ~isnan(GrNum) indicates that gridding%     is to be saved and indexed; isnan(GrNum) indicates that grid%     results are available in structure NGr, with no consideration%     of existing grid files or index.%  Aug 2015 - some Mpa to dbar edittingclear NGrNGr = []; % initialize, in case of early exit% Set input variables to default NaNs, check for required onesinVars = {'GrNum','CSci','YLIMS','zgrid','GridOvts','IgnoreOrder',...    'IgnoreGPS','GPS'};for iv=1:length(inVars)    if ~exist(inVars{iv}, 'var')        eval([inVars{iv} ' = NaN;']);    endendif ~isstruct(CSci)    disp('CSci structure missing, cannot grid, exiting ...')endif isnan(YLIMS)    disp('YLIMS info missing, cannot grid, exiting ...')endif isnan(GridOvts)    GridOvts = 0;endif isnan(IgnoreOrder)    IgnoreOrder = 0;endif isnan(IgnoreGPS) || IgnoreGPS    IgnoreGPS = 1;elseif ~isstruct(GPS)    disp('GPS structure missing, cannot grid, exiting ...')endif isnan(zgrid)    %zgrid = [floor(min(CSci.Pr)*100):1:ceil(max(CSci.Pr)*100)]; % from MPa    zgrid = [floor(min(CSci.Pr)):1:ceil(max(CSci.Pr))]; % from dbarend%%% Form gridded data for supplied data and limits ...NewZG = [zgrid(1) diff(zgrid(1:2)) zgrid(end)];%% Find indices of start/stops for pending profiles;%% given YLIMS = [yd_starts; yd_stops; UpDown]inds=[]; indf=[]; ud=[];if ~IgnoreGPS % Make sure GPS data are available for potential profiles    xx = max([0 GPS.sattime]);    ix = find(YLIMS(1,:) > xx);    if ~isempty(ix)        YLIMS(2,ix) = -YLIMS(2,ix); % No CTD data will be in limits, thus skipped    endendfor ia=1:length(YLIMS(1,:))    ib = find( CSci.yday_adj>=YLIMS(1,ia) & CSci.yday_adj<=YLIMS(2,ia) );    % keep only down/up's    if ~isempty(ib) && abs(YLIMS(3,ia))>0        inds = [inds ib(1)]; indf = [indf ib(end)];        ud = [ud YLIMS(3,ia)];    endendif isempty(inds) %% No New Profiles    returnend% specific yday limits of 24-Hz CTD data to be processed:Nyd_b = CSci.yday_adj(inds);Nyd_e = Nyd_b + (( indf-inds+1 )/24)/86400;%% Retrieve info from latest updated grid file (unless isnan(GrNum))%% (or for file to possibly be modified, if inserting missing profiles)if ~isnan(GrNum)    GrNum = length(GrdF.Index(iSet).yday_beg);endGridNew = 1; % New Grid File?  0=no, add to existing one; 1=yes (or don't file)LastGfil = [];LastSG = []; % SWIMSgrid from latest fileLastGfYDbeg = [];LastZG = [];LastPrYDbeg = [];LastPrYDend = [];%%%%%%%%%%%%% START of code for interacting with grid database %%%%%%%%%%%% First Case:  Add new profiles to existing set of grid filesif GrNum>0 && ~IgnoreOrder    LastGfil = GrdF.Index(iSet).filename{GrNum};    LastZG = GrdF.Index(iSet).zgrid(GrNum,1:3);    clear SWIMSgrid    load(fullfile(GridFld,LastGfil))    LastSG = SWIMSgrid;    clear SWIMSgrid    LastGfYDbeg = LastSG.yday(1); % beginning yday for file    % Latest profile start, end (based on 24-Hz samples processed):    LastPrYDbeg = LastSG.yday(end);     LastPrYDend = LastPrYDbeg + ...        (( LastSG.ends(end)-LastSG.starts(end)+1 )/24)/86400;    % No gridding previous to last existing profile:    ipre = find(Nyd_b < LastPrYDbeg-(15/86400));    if ~isempty(ipre)        inds(ipre)=[]; indf(ipre)=[]; ud(ipre)=[];        Nyd_b(ipre)=[]; Nyd_e(ipre)=[];        if isempty(inds) %% No New Profiles            return        end    end    % Compare first pending profile to last existing one.    % If first pending one extends incomplete existing one, compute and replace    if abs(Nyd_b(1)-LastPrYDbeg)*86400 <= 15 % pending and existing start at same time        if (Nyd_e(1)-LastPrYDend)*86400 > 5 && isequal(NewZG, LastZG)            % first pending one extends last existing one            LastSG.yday(end) = NaN; % flag to delete after new ones computed            GridNew = 0; % append to existing file        else % pending is same as existing (or grid changed), don't recompute            inds(1)=[]; indf(1)=[]; ud(1)=[];            Nyd_b(1)=[]; Nyd_e(1)=[];            if isempty(inds) %% No New Profiles                return            end        end    end    %% If ALL pending profiles are new, check whether to start new grid file    if GridNew        if ~isequal(NewZG, LastZG)            GridNew = 1; % Always start new file when depth grid changes        elseif (LastPrYDend-LastGfYDbeg)*24 > 4.0             GridNew = 1; % existing file is long enough already        elseif (Nyd_b(1)-LastPrYDend)*24 > 2            GridNew = 1; % large gap between profiles        elseif (Nyd_e(end)-LastGfYDbeg)*24 < 4.0            GridNew = 0; % APPEND to existing file, result is < 4.0 hrs worth        elseif (LastPrYDend-LastGfYDbeg)*24 < 1.5            GridNew = 0; % APPEND to short existing file        end    endend %% of First Case, new profiles into existing set of grid files% GridNew = 1; % force new file%% Second Case:  Insert missing profiles into existing set of grid filesif GrNum>0 && IgnoreOrder    GrNum = find( GrdF.Index(iSet).yday_beg < max(Nyd_e) & ...        GrdF.Index(iSet).yday_end > min(Nyd_b) );    if length(GrNum)>1        disp('Requested profile ranges span existing grid file boundaries:')        disp(' NOT GOOD - Set up new yearday limits and try again ... EXITING!')        return    elseif isempty(GrNum)        GridNew = 1; % before, between, or after existing grid files; make a new one    else        LastGfil = GrdF.Index(iSet).filename{GrNum};        LastZG = GrdF.Index(iSet).zgrid(GrNum,1:3);        if ~isequal(NewZG, LastZG)            disp('Requested profiles have grid differing from existing file:')            disp('  NOT ALLOWED - EXITING!')        end        GridNew = 0; % Alter existing file        clear SWIMSgrid        load(fullfile(GridFld,LastGfil))        LastSG = SWIMSgrid;        clear SWIMSgrid        Lydes = LastSG.yday + (( LastSG.ends-LastSG.starts+1 )/24)/86400;        %% Check if any existing profiles intersect requested ones;        %% If so, the existing ones will be removed, and replaced with new ones        for i=1:length(Nyd_b)            ix = find( LastSG.yday<Nyd_e(i) & Lydes>Nyd_b(i) );            if ~isempty(ix)                LastSG.yday(ix) = NaN; Lydes(ix) = NaN;            end        end        ix = length( find(isnan(LastSG.yday)) );        if ix>0            disp(['WARNING: Gridding these new profiles will cause removal of'])            disp([num2str(ix) ' existing ones from file = ' LastGfil ' - '])            ix = input('Enter:  1 to continue, 0 to abort');            if ix==1                disp('Okay, continuing ...')            else                disp('ABORT gridding !!')                return            end        end    endend %% of Second Case, missing profiles into existing set of grid files%%%%%%%%%%%%% END of code for interacting with grid database %%%%%%%%%%%%%% Varibles to grid: {grid field, CTD field, 0=grid only if present in CSci}VarsGridCTD = ...    {'t1', 'T1', 1;    't2', 'T2', 1;    'th1',  'Th1', 1;    'th2', 'Th2', 1;    'c1', 'C1', 1;    'c2', 'C2', 1;    's1', 'S1', 1;    's2', 'S2', 1;    'sgth1',  'Sg1', 1;    'sgth2', 'Sg2', 1;    'pitch', 'Pitch', 1;    'roll', 'Roll', 1;    'dox', 'Dox', 0;    'flu', 'Flu', 0;    'obs', 'Obs', 0;    'obs2', 'Obs2', 0;    'pH', 'pH', 0;    'sulf', 'Sulf', 0;    'h2s', 'H2S', 0;    'alt', 'Alt', 0;    'yd_byz',  'yday_adj', 1 };% Examine CTD fields, exclude optional Grid fields if not presentfor ivn=1:size(VarsGridCTD,1)    cnm = VarsGridCTD{ivn,2};    req = VarsGridCTD{ivn,3};    if ~isfield(CSci, cnm)        if ~req % this variable is not in CTD data            VarsGridCTD{ivn,3} = []; % optional field, skip        else            VarsGridCTD{ivn,3} = NaN; % required field, fill with NaNs        end    endend% If appending to file, make sure entry is made into existing Grid fieldsif ~GridNew && ~isempty(LastSG)    iok = []; % current required fields    for i=1:size(VarsGridCTD,1)        if ~isempty(VarsGridCTD{i,3})            iok = [iok i];        end    end    Ngnm = VarsGridCTD(iok,1); % fields for pending profiles    Lgnm = fieldnames(LastSG); % existing Grid profile fields    lenZ = length(LastSG.z);    for i=1:length(Lgnm)        lenV = eval(['size(LastSG.' Lgnm{i} ',1)']);        if lenV==lenZ && isempty(find( strcmp(Lgnm{i}, Ngnm) )) ...                && isempty(find( strcmp(Lgnm{i}, {'z','p'}) ))            % add to required fields, and fill with NaNs            VarsGridCTD = [VarsGridCTD; {Lgnm{i}, Lgnm{i}, NaN} ];        end    endend  % Initialize grid for specified profilesclear NGr, NGr = [];if ~isempty(inds) % grid new data    % Fill in the time vector.    NGr.yday = CSci.yday_adj(inds);    % (ends-starts)+1 indicate number of 24-Hz samples represented    NGr.starts = inds;     NGr.ends = indf;    NGr.updown = ud;    NGr.z = zgrid;    NGr.p = zgrid; % dbar     /100; %MPa    % And GPS vectors, if they are being recorded.    indgood = [];    if ~IgnoreGPS        indgood=find(~isnan(GPS.sattime));    end    if length(indgood)>1        NGr.lat = nonmoninterp1(GPS.sattime(indgood), GPS.lat(indgood), NGr.yday);        NGr.lon = nonmoninterp1(GPS.sattime(indgood), GPS.lon(indgood), NGr.yday);    else        NGr.lat = NaN*NGr.yday;        NGr.lon = NaN*NGr.yday;    end    dstr = [num2str(CSci.yday_adj(inds(1))) ' to ' num2str(CSci.yday_adj(indf(end)))];    disp(['Gridding ' num2str(length(inds)) ' profiles from ' dstr '...'])    % Now grid each profile of each variable onto the depth grid.    for ci=1:length(inds)        %disp([CSci.yday_adj(inds(ci)) CSci.yday_adj(indf(ci)) ud(ci)])        %% Grid CTD data        for ivn=1:size(VarsGridCTD,1)            gnm = VarsGridCTD{ivn,1}; cnm = VarsGridCTD{ivn,2};            req = VarsGridCTD{ivn,3};            if isempty(req)                % skip                continue             elseif isnan(req)                % all NaNs (not in CTD data)                xprof = NaN * zgrid';             else                % interpolate from CTD data                xctd = CSci.(cnm)(inds(ci):indf(ci))';                %xprof = nonmoninterp1( CSci.Pr(inds(ci):indf(ci))*100,...                %xctd, zgrid)';% Pr/MPa                xprof = nonmoninterp1( CSci.Pr(inds(ci):indf(ci)), xctd, zgrid)';            end            % put in grid matrix field            NGr.(gnm)(:,ci) = xprof;        end % of gridding CTD data for this profile         yd_pfb = CSci.yday_adj( inds(ci) );        yd_pfe = CSci.yday_adj( indf(ci) );        % (these yearday limits are now redundant to info        %  in fields yday,starts,ends)        NGr.yday_LDbeg(ci) = yd_pfb;        NGr.yday_LDend(ci) = yd_pfe;        % If requested, compute overturn stats, then grid them also        if GridOvts            clear OVT1 OVT2            [OVT1, OVT2] = Calc_ovts_grid(CSci, yd_pfb, yd_pfe);            % Force all zeros if no overturn data returned            if isempty(OVT1) || length(find(~isnan(OVT1.Z)))<3                OVT1.Z=[-1 0 999 1000];                OVT1.eps=[0 0 0 0]; OVT1.krho=[0 0 0 0]; OVT1.L_Th=[0 0 0 0];            end            if isempty(OVT2) || length(find(~isnan(OVT2.Z)))<3                OVT2.Z=[-1 0 999 1000];                OVT2.eps=[0 0 0 0]; OVT2.krho=[0 0 0 0]; OVT2.L_Th=[0 0 0 0];            end            NGr.eps1(:,ci) = nonmoninterp1(OVT1.Z, OVT1.eps, zgrid)';            NGr.krho1(:,ci) = nonmoninterp1(OVT1.Z, OVT1.krho, zgrid)';            NGr.ovt1_Th(:,ci) = nonmoninterp1(OVT1.Z, OVT1.L_Th, zgrid)';            NGr.eps2(:,ci) = nonmoninterp1(OVT2.Z, OVT2.eps, zgrid)';            NGr.krho2(:,ci) = nonmoninterp1(OVT2.Z, OVT2.krho, zgrid)';            NGr.ovt2_Th(:,ci) = nonmoninterp1(OVT2.Z, OVT2.L_Th, zgrid)';            clear OVT1 OVT2        end    end % of 'for ci=1:length(inds)'-loop, for gridding profilesend % of new gridded profiles