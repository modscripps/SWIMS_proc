function [k,P,Ps]=MySpectrum(data,nfft,dz,frsm)%function [k,P,Ps]=MySpectrum(data,nfft,dz,frsm)%Compute the spectrum of the input data.  If data is %[m x 1], then break data into overlapping chunks of %size nfft.  Return the cyclic frequency vector k, the %spectrum, and the spectrum geometrically smoothed over a %fraction (frsm) of the log-frequency bandwidth.  dz is the %sample frequency.  Of course, it works for time or depth series;%just make sure the input is a column vector.%%If the input is a matrix, then additional stability is achieved by%treating the columns as separate realizations.  In this case, the %spectrum of each column is computed as above.  The matrix of spectra%is returned in P.  Their mean is returned in Ps if frsm==0; otherwise%the geometrically smoothed mean is returned.%%See also psd, SmoothSpec.%samplefreq=1/dz;dk=samplefreq/nfft; % elementary frequency bandwidthk=(dk:dk:dk*nfft/2)'; % frequency vector for spectraif size(find(isnan(data)))~=0	disp 'warning: data contains Nans'end%demean and detrenddata=detrend(data,0);data=detrend(data);[m,n]=size(data);%Compute spectrum.  If we only have one vector, just do it.if n==1	P=psd(data,nfft,samplefreq);	% delete f=0;, normalize to preserve variance		P=P(2:length(P))/(0.5*samplefreq); else	%otherwise average all of the spectra together.	Pa=zeros(nfft/2,n);	for c=1:n		P1=psd(data(:,c),nfft,samplefreq);		P1=P1(2:length(P1))/(0.5*samplefreq);		P1a(:,c)=P1;	end	P=mean(P1a')';	end%Now do the smoothingif frsm ~=0	Ps=SmoothSpec(k,P,frsm);else	Ps=P;	ks=k;end%If a matrix was passed in, return the whole matrix of spectra.if n > 1 	P=P1a;end