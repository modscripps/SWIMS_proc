function [Rrho,angle]=Rrhofun2(s,th,p,delp,smooth);%Rrhofun: [Rrho,angle]=Rrhofun2(s,th,p,delp,smooth) - density ratio as angle%modified from Mike's to use my definition Tu(me) = Tu(mike) - 45 degs.%and also to return Rrho as well as Tu.  Note Rrho is alphaTz/betaSz, not%the other way around.  This is tested and works now.%It takes s in psu, and p in MPa.%Differs from MyRrhofun in that the differences are centered (so I don't need%a separate pr vector returned)%and the answer matrices are the same size as the originals. 8/10/00%delp is the pressure interval (in MPa) to compute the differences over.%smooth is one for smoothing over the differencing interval, zero for none.%Default = none.%	[m,n]=size(p);		alpha=sw_alpha(s,th,100*p);	beta=sw_beta(s,th,100*p);	dsdz=zeros(size(s));	dthdz=dsdz;	dp=dsdz;	%pressure interval	dzbin=nanmean(diff(p(:,1)));	%The number of bins to difference over.	dzstr=fix(delp/dzbin);	dp(1+dzstr/2:m-dzstr/2,:)=(p(1+dzstr:m,:)-p(1:m-dzstr,:));	dsdz(1+dzstr/2:m-dzstr/2,:)=-(s(1+dzstr:m,:)-s(1:m-dzstr,:))./(100*dp(1+dzstr/2:m-dzstr/2,:));	dthdz(1+dzstr/2:m-dzstr/2,:)=-(th(1+dzstr:m,:)-th(1:m-dzstr,:))./(100*dp(1+dzstr/2:m-dzstr/2,:));	%z is positive upwards.  So when s is increasing with depth dsdz < 0.	%t decreasing with depth --> dtdz > 0.  So     %dsdz = -diff(s)./diff(p);    %dthdz = -diff(th)./diff(p);%    bs = -beta.*dsdz;%    at = alpha.*dthdz;%	angle=atan((at - bs)./(at+bs));%12/30/99 changes below.  Turner angle was mapped improperly%when it was less than -pi/2.    bs = beta.*dsdz;    at = alpha.*dthdz;	Rrho=zeros(size(s))*NaN;	ind=find(bs~=0);	Rrho(ind)=at(ind)./bs(ind);	angle=atan(-Rrho)-pi/4;		ipi=find(angle<-pi/2);	angle(ipi)=angle(ipi)+pi;	%angle=atan2(at+bs,at-bs);	if exist('smooth') 		if smooth == 1					angle=CenteredConv(angle,1,dzstr);			Rrho=CenteredConv(angle,1,dzstr);		end	end