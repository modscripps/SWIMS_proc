function Dox = Dox_sbe(DoxV, T, S, P, DoxCoef)%function Dox = Dox_sbe(DoxV, T, S, P, DoxCoef)% Compute Dox = dissolved oxygen [ml/l], given:  DoxV = raw Volts (0 to 5),%   T,S,P: temperature (degC, in situ), salinity (PSU), pressure(dbar),%   and DoxCoef = structure of calibration coefficients.% apr-2002, DPW% Jan-2012 (dpw) - revised code to use SBE's STandarD formula and%   coeffs (A,B,C, D1,D2,tau20, E; ignore H1,H2,H3) with tau(P,T);%   also uses newer sw_oxsol.m instead of sw_satO2.m;%   earlier version had 'HomeGrown' tau implemented (dox_tau0).% Jun-2015 (dpw) - modified to use S/PSU, P/dbar and sw_satO2.m (for HG)Dox = NaN*DoxV;Lag = 0;Tau_0 = 0;  % time constant, in case of future re-implementation (HG)Tau_Ft = 0; % possible coef for temperature dependence (HG)Tau20 = NaN; % for STDEnom = 0.036; % in STD formulaFS_lf=24; % sample rate in HzdNH = 36; % for dVolts/dt, center-difn using points +/-dNH awaydNH = min( dNH, floor( length(Dox)/2 - .49) ); % in case of too few points% Tau = 4.4; % response time scale, seconds (during aeg04; also for bs03??)% Shift scans here (T,S also, to get proper sw_satO2()? - NO:2011)if isfield(DoxCoef, 'dox_lag'); % for either method    if ~isempty(DoxCoef.dox_lag)        Lag = DoxCoef.dox_lag;    endendif abs(Lag)>1e-10    DoxV = shift(DoxV, Lag);    %T = shift(T, Lag);    %S = shift(S, Lag);end% option for specified response-time parametersif isfield(DoxCoef, 'dox_tau0');    if ~isempty(DoxCoef.dox_tau0)        Tau_0 = DoxCoef.dox_tau0;    endendif isfield(DoxCoef, 'dox_tauFt');    if ~isempty(DoxCoef.dox_tauFt)        Tau_Ft = DoxCoef.dox_tauFt;    endend% check for STD method coeffsif isfield(DoxCoef,'A') && ~isnan(DoxCoef.A)    Mtyp = 'STD';    if ~isfield(DoxCoef,'E')        DoxCoef.E = Enom;    end    if isfield(DoxCoef, 'Tau20') && ~isempty(DoxCoef.Tau20)        Tau20 = DoxCoef.Tau20;    end    if ~isnan(Tau20)        Tau = Tau20 .* exp(DoxCoef.D1.*P + DoxCoef.D2.*(T-20));    else        Tau = 0;    endelse    Mtyp = 'HG';    Tau = Tau_0; % + func(T; Tau_Ft);enddoxdt = 0; if dNH > 0 && ~isempty(find(Tau)>1e-10) % compute dV/dt for response-time correction    clear vx tx     vx = DoxV; tx = [1:length(vx)] / FS_lf;    fp = dNH+1; lp = length(vx)-dNH;    dv = ( vx(fp+dNH:lp+dNH) - vx(fp-dNH:lp-dNH) );    dt = ( tx(fp+dNH:lp+dNH) - tx(fp-dNH:lp-dNH) );    for i = dNH-1:-1:1 % use fewer points near ends        x(1)=( vx(2*i+1)-vx(1) ); x(2)=( vx(end)-vx(end-2*i) );        y(1)=( tx(2*i+1)-tx(1) );  y(2)=( tx(end)-tx(end-2*i) );        dv = [x(1), dv, x(2)];  dt = [y(1), dt, y(2)];    end    % fwd/bwd difn at ends    dv = [ (vx(2)-vx(1)), dv, (vx(end)-vx(end-1)) ];    dt = [ tx(2)-tx(1), dt, tx(end)-tx(end-1) ];    doxdt = dv ./ dt;endswitch Mtyp    case 'HG'        Dox = ( DoxCoef.Soc * ((DoxV+DoxCoef.Voffset) + (Tau.*doxdt))+0 ) ...            .* exp(DoxCoef.TCor*T + DoxCoef.PCor*P) .* sw_satO2(S,T);    case 'STD'        Dox = (DoxCoef.Soc * (DoxV+DoxCoef.Voffset + Tau.*doxdt)) ...            .* (1+T.*(DoxCoef.A+T.*(DoxCoef.B+T.*DoxCoef.C))) ...            .* exp(DoxCoef.E*P./(T+273.15)) .* sw_oxsol(T,S);end% Zero is minimum, fix any negativesix = find(Dox<0);Dox(ix) = 0;